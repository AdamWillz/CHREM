#!/usr/bin/perl

# ====================================================================
# CREST_AL.pl
# Author: Adam Wills
# Date: Jul 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use Data::Dumper;	# to dump info to the terminal for debugging purposes
use File::Copy;
use Storable  qw(dclone);
use XML::Simple; # to parse the XML results files
use XML::Dumper;

use lib qw(../../scripts/modules);
use General;
use Cross_reference;
use AL_Profile_Gen;
use Upgrade;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

our $hse_type;   
our $region;
our $Target;                 # Target average annual lighting consumption for region and hse_type [kWh/yr/hsehld]
our @BTypes;                 # Array to hold all bulb categories
our $occ_strt;               # HASH holding the active occupants at first timestep pdf
our $light_sim;              # HASH holding lighting sim data
our $CREST;                  # HASH holding CREST input data
my $phi = 1.61803398874989;  # Golden ratio

# --------------------------------------------------------------------
# Declare the local variables
# --------------------------------------------------------------------

my $hse_types;	    # declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	    # declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $xlow;
my $xu;
my @hse_TOT;        # Array to hold the list of all houses for region and type
my @hse_list;        # Array to hold the subset of houses for this region and type
my $MAXTOL = 0.001; # Maximum error estimate [%]
my $MaxIter = 35;   # Maximum iterations
my $SubSet = 377;   # Number of houses to run each iteration

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV < 5) {die "Four arguments are required: house_type region Target low high\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions) = &hse_types_and_regions_and_set_name(shift(@ARGV), shift(@ARGV));
my $Num_Keys = keys $hse_types;
if($Num_Keys>1) {die "This script can only handle one house type at a time"};
foreach my $stuff (keys (%{$hse_types})) {
    $hse_type = $hse_types->{$stuff};
};
    
$Num_Keys = keys $regions;
if($Num_Keys>1) {die "This script can only handle one region at a time"};
foreach my $stuff (keys (%{$regions})) {
    $region = $regions->{$stuff};
};

$Target = shift (@ARGV);
if ($Target <=0) {die "Invalid energy consumption target $Target. Must be positive"};

$xlow = shift (@ARGV);
if ($xlow <=0) {die "Invalid lower calibration scalar $xlow. Must be positive"};

$xu = shift (@ARGV);
if ($xu <=0 || $xu < $xlow) {die "Invalid higher calibration scalar $xu. Must be positive and greater than $xlow"};

# --------------------------------------------------------------------
# Set the CREST input data
# --------------------------------------------------------------------
my $LogFile = "GoldenSection_" . $hse_type . "_" . "$region.log";
open(my $LogFH, '>', $LogFile) or die ("Can't open datafile: $LogFile");
SET_CREST: {
    my @CHREMBulbs = qw(Fluorescent Halogen Incandescent);
    # --------------------------------------------------------------------
    # Create an climate reference crosslisting hash
    # --------------------------------------------------------------------
    my $climate_ref = &cross_ref_readin('../../climate/Weather_HOT2XP_to_CWEC.csv');

    # --------------------------------------------------------------------
    # Load in CHREM NN data
    # --------------------------------------------------------------------
    my $NNinPath = '../../NN/NN_model/ALC-Inputs-V2.csv';
    my $NNinput = &cross_ref_readin($NNinPath);
    print "Loading Irradiance data\n";
    
    # --------------------------------------------------------------------
    # Load in the irradiance data
    # --------------------------------------------------------------------
    my $IrrDir = "Global_Horiz/$region";
    opendir (DIR, $IrrDir) or die $!;
    while (my $file = readdir(DIR)) {
        if ($file =~ m/out$/) {
            my $irradiance = "Global_Horiz/$region/$file";
            my $Irr_ref = &GetIrradiance($irradiance); # Load the irradiance data
            my @Irr = @$Irr_ref;
            $CREST->{'Irradiance'}->{$file}=\@Irr;
        };
    };
    closedir(DIR);
    print "Done\n";

    # --------------------------------------------------------------------
    # Scan the CSDDRD
    # --------------------------------------------------------------------
    my $record = '../../CSDDRD/2007-10-31_EGHD-HOT2XP_dupl-chk_A-files_region_qual_pref_' . $hse_type . '_subset_' . $region;
    my $exten = '.csv';
    my $CSDDRD; # declare a hash reference to store the CSDDRD data. This will only store one house at a time and the header data
    open (my $LIST, '<', $record . $exten) or die ("Can't open datafile: $record$exten");	# open readable file
    REC: while ($CSDDRD = &one_data_line($LIST, $CSDDRD)) { # Each house in the CSDDRD record
        my $hse_name = $CSDDRD->{'file_name'};
        my $hse_occ; # Number of occupants in dwelling
        
        # Get the name of the dwelling
        $hse_name =~ s{\.[^.]+$}{}; # Remove any extensions
        
        # --------------------------------------------------------------------
        # Find NN data
        # --------------------------------------------------------------------
        my $NNdata;
        if (exists $NNinput->{'data'}->{"$hse_name.HDF"}) {
            $NNdata = $NNinput->{'data'}->{"$hse_name.HDF"};
        } elsif (exists $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"}) {
            $NNdata = $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"};
        } else {
            #$issue++;
            #$return->{$hse_name}->{"$issue"} = "Error: Couldn't find NN record";
            #next RECORD;
            print $LogFH "Error: Couldn't find NN record for $hse_name\n";
            next REC;
        };
        # --------------------------------------------------------------------
        # Determine number of occupants
        # --------------------------------------------------------------------
        $hse_occ = $NNdata->{'Num_of_Children'}+$NNdata->{'Num_of_Adults'};
        if ($hse_occ>5) {   # WARN THE USER THE NUMBER OF OCCUPANTS EXCEEDS MODEL LIMITS
            #$issue++;
            #$return->{$hse_name}->{"$issue"} = "Warning: Occupants exceeded 5";
            #$hse_occ=5;
            print $LogFH "Warning: Occupants $hse_occ exceeded 5 for $hse_name\n";
        };
        
        # --------------------------------------------------------------------
        # Determine number of bulbs/lamps in dwelling
        # --------------------------------------------------------------------
        my $iBulbs=0; # Number of bulbs/lamps for dwelling 
        foreach my $bulb (@CHREMBulbs) { # Read number of bulbs in dwelling from CHREM NN inputs
            $iBulbs = $iBulbs + $NNdata->{$bulb};
        };
        
        # --------------------------------------------------------------------
        # Get climate file for this house
        # --------------------------------------------------------------------
        my $loc = $climate_ref->{'data'}->{$CSDDRD->{'HOT2XP_CITY'}}->{'CWEC_FILE'};  # Determine climate for this dwelling
        $loc =~ s{\.[^.]+$}{}; # Remove extension
        $loc = $loc . '.out'; # Name of irradiance file
        
        # --------------------------------------------------------------------
        # Update the list and CREST inputs for the house
        # --------------------------------------------------------------------
        push(@hse_TOT,$hse_name);
        $CREST->{$hse_name}->{'Irrad_file'} = $loc;
        $CREST->{$hse_name}->{'Num_Occ'} = $hse_occ;
        $CREST->{$hse_name}->{'Num_Bulbs'} = $iBulbs;
    }; # END REC
    close $LIST;
}; # END CSDDRD_READ
close $LogFH;

my($new_ref,$dummy)=&random_hse_shuffle(\@hse_TOT,$SubSet);
@hse_list = @$new_ref;

# --------------------------------------------------------------------
# Load in CREST Databases
# --------------------------------------------------------------------
print "Reading in the occupant start state XML - ";
my $OccSTART = 'Occ_Lighting/occ_start_states.xml';
$occ_strt = XMLin($OccSTART);
print "Complete\n";

print "Reading in the light simulation parameters XML - ";
my $LIGHT = 'Occ_Lighting/lightsim_inputs.xml';
$light_sim = XMLin($LIGHT);
print "Complete\n";

foreach my $blb (keys (%{$light_sim->{'Types'}})) { # Read an store all bulb categories
    push(@BTypes,$blb);
};

# --------------------------------------------------------------------
# Use Golden-Section Search to determine the minimum (Function is never negative)
# --------------------------------------------------------------------
my $datestring = localtime();
print "Starting the search at $datestring\n";
GOLDEN: {
    my $f1;
    my $f2;
    my $pred1;
    my $pred2;
    # Generate interior points
    my $d = 0.61803*($xu-$xlow);
    my $x1 = $xlow + $d;
    my $x2 = $xu - $d;
    
    # Evaluate the interior points
    ($f1,$pred1) = main(\@hse_list,$x1);
    ($f2,$pred2) = main(\@hse_list,$x2);
    
    # Loop until convergence or max. iterations
    my $count = 1;
    my $ea;  # Error estimation
    my $xmin;
    my $fmin;
    ITERATOR: while ($count <= $MaxIter) {
        if ($f1 < $f2) { # x1 most likely candidate for minimum
            # Check for convergence
            $ea = (2-$phi)*abs(($xu-$xlow)/$x1)*100; # Error estimate [%]
            $datestring = localtime();
            print "$datestring: Minimum: $f1, Scalar: $x1, Error:$ea\n";
            if ($ea <= $MAXTOL) {
                $xmin = $x1;
                $fmin = $f1;
                last ITERATOR;
            };
            
            # Update the domain
            $xlow=$x2;
            $x2=$x1;
            $f2=$f1;

            # Evaluate the new interior point
            $d = 0.61803*($xu-$xlow);
            $x1=$xlow + $d;
            ($f1,$pred1) = main(\@hse_list,$x1);
            
        } else { # x2 most likely candidate for minimum
            # Check for convergence
            $ea = (2-$phi)*abs(($xu-$xlow)/$x2)*100; # Error estimate [%]
            $datestring = localtime();
            print "$datestring: Minimum: $f2, Scalar: $x2, Error:$ea\n";
            if ($ea <= $MAXTOL) {
                $xmin = $x2;
                $fmin = $f2;
                last ITERATOR;
            };

            # Update the domain
            $xu=$x1;
            $x1=$x2;
            $f1=$f2;
            # Evaluate the new interior point
            $d = 0.61803*($xu-$xlow);
            $x2 = $xu - $d;
            ($f2,$pred2) = main(\@hse_list,$x2);
        };
        $count++;
    }; # END ITERATOR

    my $bNonconverge = 0;
    if ($count>$MaxIter) {$bNonconverge = 1};
    if ($bNonconverge) { # Non-convergence
        if ($f1 < $f2) {
            $fmin = $f1;
            $xmin = $x1;
        } else {
            $fmin = $f2;
            $xmin = $x2;
        };
    };
    
    $datestring = localtime();
    print "Finished iterating at $datestring\n";
    print "Minimum scalar $xmin with absolute true difference of $fmin\n\n";

    RESOUT: { # Print out results

        my $ResFile = "GoldenSearch_" . "$hse_type" . "_" . "$region" . ".res";
        open (my $RESfh, '>', $ResFile) or die "Cannot print output file $ResFile";
        
        print $RESfh "Target was $Target\n";
        print $RESfh "Minimum target difference of $fmin\n";
        print $RESfh "for scalar $xmin\n";
        if($bNonconverge){print $RESfh "WARNING: max iterations of $MaxIter reached\n"};
        
        close $RESfh;

    }; # END RESOUT

}; # END GOLDEN 

# --------------------------------------------------------------------
# Main calculation subroutine
# --------------------------------------------------------------------
sub main {

    my $list_ref = shift;
    my $fCalibrationScalar = shift;
    my @houses = @$list_ref;
    
    my $kWhAverage; 
    my @AggAnnual=();
    my $TrueError;      # Relative value for true error [%]
    my @Occ_keys=qw(zero one two three four five six);

    # --------------------------------------------------------------------
    # Begin processing each house model for the region and house type
    # --------------------------------------------------------------------
    RECORD: foreach my $hse_name (@houses) {
        my @Occ; # Array to hold occupancy
        my $issue = 0;      # Issue counter
        my $hse_occ = $CREST->{$hse_name}->{'Num_Occ'};
        my $iBulbs = $CREST->{$hse_name}->{'Num_Bulbs'};
        my $loc = $CREST->{$hse_name}->{'Irrad_file'};
        my $Irr_ref = $CREST->{'Irradiance'}->{$loc};
        my @Irr = @$Irr_ref;

        # --------------------------------------------------------------------
        # Generate the occupancy profiles
        # --------------------------------------------------------------------
        my $IniState = &setStartState($hse_occ,$occ_strt->{'wd'}->{"$Occ_keys[$hse_occ]"}); # TODO: Determine 'we' or 'wd'
        my $Occ_ref = &OccupancySimulation($hse_occ,$IniState,4); # TODO: Determine day of the week
        @Occ = @$Occ_ref;
    
        # --------------------------------------------------------------------
        # Generate Lighting Profile
        # --------------------------------------------------------------------
        # --- Bulb data
        my @fBulbs = (); # Array to hold wattage of each bulb in the dwelling
        # Assign wattage for each bulb
        for (my $i=1;$i<=$iBulbs;$i++) { # Each bulb
            my $r1 = rand();
            my $cml=0;
            my $category;
            Category: foreach my $blb (@BTypes) { # Loop through each bulb category
                $cml=$cml+$light_sim->{'Types'}->{$blb}->{'Share'};
                if ($r1<=$cml) {
                    $category=$blb;
                    last Category;
                };
            }; # END Category
    
            # Reset variables
            $r1 = rand();
            $cml=0;
            my $BulbSubC;
            BulbSub: foreach my $blb (keys (%{$light_sim->{'Types'}->{$category}->{'sub'}})) { # Loop through each bulb sub-category
                $cml=$cml+$light_sim->{'Types'}->{$category}->{'sub'}->{$blb}->{'Share'};
                if ($r1<=$cml) {
                    $BulbSubC=$blb;
                    last BulbSub;
                };
            }; # END BulbSub
            if (not defined($BulbSubC)) {
                print "Category is $category\n";
                print "Random Number is $r1\n";
                print "Cumulative is $cml\n";
                die "Please check the distribution data";
            };
            # Store wattage of this bulb
            push(@fBulbs, $light_sim->{'Types'}->{$category}->{'sub'}->{$BulbSubC}->{'Wattage'});
        };
    
        # --- Call Lighting Simulation
        my $MeanThresh = $light_sim->{'threshold'}->{'mean'};
        my $STDThresh = $light_sim->{'threshold'}->{'std'};
        my ($light_ref,$AnnPow) = &LightingSimulation(\@Occ,\@Irr,\@fBulbs,$fCalibrationScalar,$MeanThresh,$STDThresh);
        my @Light = @$light_ref;
        push(@AggAnnual,$AnnPow);

    }; # END RECORD

    # --------------------------------------------------------------------
    # determine the average per household
    # --------------------------------------------------------------------
    my $Agg=0;
    my $Nhousehold = scalar @AggAnnual;
    foreach my $load (@AggAnnual) {
        $Agg=$Agg+$load;
    };
    $kWhAverage = $Agg/$Nhousehold;

    # Determine the absolute true error
    $TrueError = abs($Target-$kWhAverage);
    
    return($TrueError,$kWhAverage);

}; # END sub main 