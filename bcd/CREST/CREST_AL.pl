#!/usr/bin/perl

# ====================================================================
# CREST_AL.pl
# Author: Adam Wills
# Date: Jul 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use threads;	# threads-1.89 (to multithread the program)
use Data::Dumper;	# to dump info to the terminal for debugging purposes
use File::Copy;
use Storable  qw(dclone);
use POSIX qw(ceil floor);
use XML::Simple; # to parse the XML results files
use XML::Dumper;

use lib qw(../../scripts/modules);
use General;
use Cross_reference;
use AL_Profile_Gen;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my $occ_strt;   # HASH for occupancy initial condition PDF
my $NNinput;    # HASH for NN Input Data
#my $NNoutput;   # HASH for NN Output Data
my $light_sim;  # HASH holding light simulation data
my $App;        # HASH holding general appliance data
my $ColdApp;    # HASH to hold the cold appliance data
my $Climate;    # HASH to hold each dwellings climate file
my $Irradiance; # HASH to hold irradiance data
my $Activity;   # HASH holding the activity statistics



# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV < 3) {die "Three arguments are required: house_types regions set_name\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
#if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
#}
#else { # An inappropriate set_name was provided so die and leave a message
#	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
#};
LOAD_EXT: {
    # --------------------------------------------------------------------
    # Load in CHREM NN data
    # --------------------------------------------------------------------
    my $NNinPath = '../../NN/NN_model/ALC-Inputs-V2.csv';
    $NNinput = &cross_ref_readin($NNinPath);
    #my $NNresPath = '../../NN/NN_model/ALC-Results.csv';
    #$NNoutput = &cross_ref_readin($NNresPath);
    
    # --------------------------------------------------------------------
    # Load in CREST Databases
    # --------------------------------------------------------------------
    my $OccSTART = 'Occ_Lighting/occ_start_states.xml';
    $occ_strt = XMLin($OccSTART);
    
    my $LIGHT = 'Occ_Lighting/lightsim_inputs.xml';
    $light_sim = XMLin($LIGHT);
    
    # --------------------------------------------------------------------
    # Load in general appliance data
    # --------------------------------------------------------------------
    my $AppFiles =  'Appliance/Appliance_inputs.xml';
    $App = XMLin($AppFiles);
    
    # --------------------------------------------------------------------
    # Load in cold appliance data
    # --------------------------------------------------------------------
    my $ColdFile = 'Appliance/Cold/Refrigerator_dist.xml';
    $ColdApp->{'Refrigerator'}->{'dist'}=XMLin($ColdFile);
    $ColdFile = 'Appliance/Cold/Refrigerator_eff.xml';
    $ColdApp->{'Refrigerator'}->{'eff'}=XMLin($ColdFile);
    
    $ColdFile = 'Appliance/Cold/Freezer_dist.xml';
    $ColdApp->{'Freezer'}->{'dist'}=XMLin($ColdFile);
    $ColdFile = 'Appliance/Cold/Freezer_eff.xml';
    $ColdApp->{'Freezer'}->{'eff'}=XMLin($ColdFile);
    
    # -----------------------------------------------
    # Store the associated climate for each dwelling
    # -----------------------------------------------
    print 'Loading the climate data for each region and house type';
    
    my $climate_ref = &cross_ref_readin('../../climate/Weather_HOT2XP_to_CWEC.csv');	# create an climate reference crosslisting hash
    
    foreach my $region (values (%{$regions})) {
		foreach my $hse_type (values (%{$hse_types})) {
            my $file = '../../CSDDRD/2007-10-31_EGHD-HOT2XP_dupl-chk_A-files_region_qual_pref_' . $hse_type . '_subset_' . $region;
            my $ext = '.csv';
            my $CSDDRD_FILE;
            open ($CSDDRD_FILE, '<', $file . $ext) or die ("Can't open datafile: $file$ext");	# open readable file
            CSDDRD: while ($CSDDRD = &one_data_line($CSDDRD_FILE, $CSDDRD)) {
                my $hse_name = $CSDDRD->{'file_name'};
                $hse_name =~ s{\.[^.]+$}{}; # Remove any extensions
                # --------------------------------------------------------------------
                # Get climate file for this house
                # --------------------------------------------------------------------
                my $loc = $climate_ref->{'data'}->{$CSDDRD->{'HOT2XP_CITY'}}->{'CWEC_FILE'};  # Determine climate for this dwelling
                $loc =~ s{\.[^.]+$}{}; # Remove extension
                $loc = $loc . '.out'; # Name of irradiance file
                $Climate->{$hse_name}=$loc;
            }; # END CSDDRD
            close $CSDDRD_FILE;
        };
        
        # --------------------------------------------------------------------
        # Load in the irradiance data for this region
        # --------------------------------------------------------------------
        my $IrrDir = "Global_Horiz/$region";
        opendir (DIR, $IrrDir) or die $!;
        while (my $file = readdir(DIR)) {
            if ($file =~ m/out$/) {
                my $Rad = "Global_Horiz/$region/$file";
                my $Irr_ref = &GetIrradiance($Rad); # Load the irradiance data
                my @Irr = @$Irr_ref;
                $Irradiance->{$file}=\@Irr;
            };
        };
        closedir(DIR);
    };
    print " - Complete\n";

    # -----------------------------------------------
    # Store the associated climate for each dwelling
    # -----------------------------------------------
    print 'Loading the activity statistics';
    my $ActStatpth = 'Appliance/activity_stats.csv';
    $Activity = &ActiveStatParser($ActStatpth);
    print " - Complete\n";
}; # END LOAD_EXT
# --------------------------------------------------------------------
# Begin multi-threading for regions and house types
# --------------------------------------------------------------------
MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
          
        };
    };
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        my $return; # HASH to store issues
        my $issue = 0; # Issue counter
        my @Occ_keys=qw(zero one two three four five six);
        my @BTypes=(); # Array to hold all bulb categories
        foreach my $blb (keys (%{$light_sim->{'Types'}})) { # Read an store all bulb categories
            push(@BTypes,$blb);
        };

        push (my @dirs, <../../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        #print Dumper @dirs;

        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        RECORD: foreach my $dir (@dirs) {
            my $hse_name = $dir;
            $hse_name =~ s{.*/}{};
            my $hse_occ; # Number of occupants in dwelling
            my @Occ; # Array to hold occupancy 
            my @Light; # Array to hold the lighting power draw at every minute [kW]
            my @TotalCold=(0) x 525600; # Array to hold the total power draw of all cold appliances [kW]
            my @TotalOther=(0) x 525600; # Array to hold the total power draw of all other appliances [kW]
            my $loc = $Climate->{$hse_name}; # Name of climate file for this house
            my $Irr_ref = $Irradiance->{$loc}; # Irradiance data for this climate [W/m2]
            my @Irr = @$Irr_ref;
            my $MeanActOcc=0;
            
            # --------------------------------------------------------------------
            # Find NN data
            # --------------------------------------------------------------------
            my $NNdata;
            if (exists $NNinput->{'data'}->{"$hse_name.HDF"}) {
                $NNdata = $NNinput->{'data'}->{"$hse_name.HDF"};
            } elsif (exists $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"}) {
                $NNdata = $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"};
            } else {
                $issue++;
                $return->{$hse_name}->{"$issue"} = "Error: Couldn't find NN record";
                next RECORD;
            };

            #my $NNo;
            #if (exists $NNoutput->{'data'}->{"$hse_name.HDF"}) {
            #    $NNo = $NNoutput->{'data'}->{"$hse_name.HDF"};
            #} elsif (exists $NNoutput->{'data'}->{"$hse_name.HDF.No-Dryer"}) {
            #    $NNo = $NNoutput->{'data'}->{"$hse_name.HDF.No-Dryer"};
            #} else {
            #    $issue++;
            #    $return->{$hse_name}->{"$issue"} = "Error: Couldn't find NN output";
            #    next RECORD;
            #};

            # --------------------------------------------------------------------
            # Generate the occupancy profiles
            # --------------------------------------------------------------------
            OCC: {
                $hse_occ = $NNdata->{'Num_of_Children'}+$NNdata->{'Num_of_Adults'};
                if ($hse_occ>5) {   # WARN THE USER THE NUMBER OF OCCUPANTS EXCEEDS MODEL LIMITS
                    print "For $hse_type $region $hse_name, number of occupants $hse_occ exceeds model limit 5. Setting to 5\n";
                    $hse_occ=5;
                };
                my $IniState = &setStartState($hse_occ,$occ_strt->{'wd'}->{"$Occ_keys[$hse_occ]"}); # TODO: Determine 'we' or 'wd'
                my $Occ_ref = &OccupancySimulation($hse_occ,$IniState,4); # TODO: Determine day of the week
                @Occ = @$Occ_ref;
                
                # Determine the mean active occupancy
                foreach my $Step (@Occ) {
                    if($Step>0) {$MeanActOcc++};
                };
                $MeanActOcc=$MeanActOcc/($#Occ+1); # Fraction of time occupants are active
            };
            # --------------------------------------------------------------------
            # Generate Lighting Profile
            # --------------------------------------------------------------------
            #LIGHTING: {
            #    # --- Bulb data
            #    my @fBulbs = (); # Array to hold wattage of each bulb in the dwelling
            #    my $iBulbs=0; # Number of bulbs/lamps for dwelling 
            #    my @BulbType = qw(Fluorescent Halogen Incandescent);
            #    foreach my $bulb (@BulbType) { # Read number of bulbs in dwelling from CHREM NN inputs
            #        $iBulbs = $iBulbs + $NNdata->{$bulb};
            #    };
            #    # Assign wattage for each bulb
            #    for (my $i=1;$i<=$iBulbs;$i++) { # Each bulb
            #        my $r1 = rand();
            #        my $cml=0;
            #        my $category;
            #        Category: foreach my $blb (@BTypes) { # Loop through each bulb category
            #            $cml=$cml+$light_sim->{'Types'}->{$blb}->{'Share'};
            #            if ($r1<$cml) {
            #                $category=$blb;
            #                last Category;
            #            };
            #        }; # END Category
            #
            #        # Reset variables
            #        $r1 = rand();
            #        $cml=0;
            #        my $BulbSubC;
            #        BulbSub: foreach my $blb (keys (%{$light_sim->{'Types'}->{$category}->{'sub'}})) { # Loop through each bulb sub-category
            #            $cml=$cml+$light_sim->{'Types'}->{$category}->{'sub'}->{$blb}->{'Share'};
            #            if ($r1<$cml) {
            #                $BulbSubC=$blb;
            #                last BulbSub;
            #            };
            #        }; # END BulbSub
            #        if (not defined($BulbSubC)) {
            #            print "Category is $category\n";
            #            print "Random Number is $r1\n";
            #            print "Cumulative is $cml\n";
            #            die "Please check the distribution data";
            #        };
            #        # Store wattage of this bulb
            #        push(@fBulbs, $light_sim->{'Types'}->{$category}->{'sub'}->{$BulbSubC}->{'Wattage'});
            #    };
            #
            #    # --- Call Lighting Simulation
            #    my $fCalibrationScalar = $light_sim->{"_$region"}->{"_$hse_type"}->{'Calibration'};
            #    my $MeanThresh = $light_sim->{'threshold'}->{'mean'};
            #    my $STDThresh = $light_sim->{'threshold'}->{'std'};
            #    my ($light_ref,$AnnPow) = &LightingSimulation(\@Occ,\@Irr,\@fBulbs,$fCalibrationScalar,$MeanThresh,$STDThresh);
            #    @Light = @$light_ref;
            #}; # END LIGHTING
            
            # --------------------------------------------------------------------
            # Generate Cold appliance profiles
            # --------------------------------------------------------------------
            #COLD: {
            #    my @Cold_key = qw(Main_Refrigerator Secondary_Refrigerator Main_Freezer Secondary_Freezer); # Keys for each type of cold appliance in NN inputs
            #    foreach my $cold (@Cold_key) { # Determine what cold appliances this dwelling has
            #        if ($NNdata->{"$cold"} > 0) { # Dwelling has this type of cold appliance
            #            my $ColdSize = $NNdata->{"$cold"}/28.316847; # Convert size to cu. ft
            #            # Determine if fridge or freezer
            #            my ($ColdType) = $cold =~ m/_(.*)/;
            #            my ($Colduse) = $cold =~ m/(.*)_/;
            #            my $ColdRef = $ColdApp->{"$ColdType"}; # Create a hash reference to the data
            #            
            #            # Randomly select appliance vintage from distribution
            #            my $NumVint = $ColdRef->{'dist'}->{'Periods'}->{'intervals'}; # Number of vintage intervals
            #            my $InterVint=1; # Index the vintage interval
            #            my $fCumulativeP = 0;
            #            my $fRand = rand();
            #            COLD_VINT: while ($InterVint<=$NumVint) {
            #                $fCumulativeP = $fCumulativeP +  $ColdRef->{'dist'}->{$Colduse}->{"_$region"}->{"_$InterVint"};
            #                if ($fRand < $fCumulativeP) {last COLD_VINT};
            #                $InterVint++;
            #            }; # END COLD_VINT
            #            my $vintage = rand_range($ColdRef->{'dist'}->{'Periods'}->{"_$InterVint"}->{'min'},$ColdRef->{'dist'}->{'Periods'}->{"_$InterVint"}->{'max'});
            #            
            #            # Determine the corresponding UEC for this vintage and appliance type (Refrigerator,Chest_Freezer,Upright_Freezer)
            #            my ($UEC,$cType) = &GetUEC($ColdType,$vintage,$ColdSize,$ColdRef->{'eff'});
            #            
            #            # Generate the annual appliance profile for this appliance
            #            my $CalibCyc = $App->{'Calibration'}->{"_$region"}*$App->{'Types_Cold'}->{$cType}->{'Base_cycles'}; # Calibrated mean cycles per year
            #            my $Cold_Ref = &setColdProfile($UEC,$CalibCyc,$App->{'Types_Cold'}->{$cType}->{'Mean_cycle_L'},$App->{'Types_Cold'}->{$cType}->{'Restart_Delay'});
            #            my @ThisCold = @$Cold_Ref;
            #            
            #            # Update the total cold appliance power draw [kW]
            #            for (my $k=0; $k<=$#ThisCold;$k++) {
            #                $TotalCold[$k]=$TotalCold[$k]+$ThisCold[$k];
            #            };
            #        };
            #    };
            #}; # END COLD
            
            # --------------------------------------------------------------------
            # Generate the profiles of all other appliances
            # --------------------------------------------------------------------
            # Determine the appliance stock of this dwelling
            my @AppStock=();
            my $AppStock_ref = &GetApplianceStock($NNdata,$region);
            @AppStock=@$AppStock_ref;
            
            foreach my $item (@AppStock) { # For each appliance in the dwelling
                # Load the appropriate appliance data
                my $sUseProfile=$App->{'Types_Other'}->{$item}->{'Use_Profile'}; # Type of usage profile
                my $iMeanCycleLength=$App->{'Types_Other'}->{$item}->{'Mean_cycle_L'}; # Mean length of cycle [min]
                my $iCyclesPerYear=$App->{'Types_Other'}->{$item}->{'Base_cycles'}*$App->{"_$region"}->{'Calibration'}; # Calibrated number of cycles per year
                my $iStandbyPower=$App->{'Types_Other'}->{$item}->{'Standby'}; # Standby power [W]
                my $iRatedPower=$App->{'Types_Other'}->{$item}->{'Mean_Pow_Cyc'}; # Mean power per cycle [W]
                my $iRestartDelay=$App->{'Types_Other'}->{$item}->{'Restart_Delay'}; # Delay restart after cycle [min]
                my $fAvgActProb=$App->{'Types_Other'}->{$item}->{'Avg_Act_Prob'}; # Average activity probability [-]
                my $sOccDepend=$App->{'Types_Other'}->{$item}->{'Avg_Act_Prob'}; # Active occupant dependent

                # Call the appliance simulation
                my $ThisApp_ref = &GetApplianceProfile(\@Occ,$item,$sUseProfile,$iMeanCycleLength,$iCyclesPerYear,$iStandbyPower,$iRatedPower,$iRestartDelay,$fAvgActProb,$Activity,$MeanActOcc,4);
                my @ThisApp = @$ThisApp_ref;
                
                # Update the TotalOther array
                for(my $k=0;$k<=$#TotalOther;$k++) {
                    $TotalOther[$k]=$TotalOther[$k]+$ThisApp[$k];
                };
            
            };

        }; # END RECORD
        
    print "AL profiles for $hse_type $region - Complete\n";
    
    return ($return);
    
    };  # END sub main
};	# END MAIN

# -----------------------------------------------
# Subroutines
# -----------------------------------------------
SUBROUTINES: {
    sub rand_range {
        my ($x, $y) = @_;
    return int(rand($y - $x)) + $x;
    };

};
