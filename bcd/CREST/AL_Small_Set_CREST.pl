#!/usr/bin/perl

# ====================================================================
# CREST_AL.pl
# Author: Adam Wills
# Date: Oct 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use Data::Dumper;	# to dump info to the terminal for debugging purposes
use File::Copy;
use Storable  qw(dclone);
use XML::Simple; # to parse the XML results files
use XML::Dumper;
use threads;
use threads::shared;
use POSIX qw(ceil floor);

use lib qw(../../scripts/modules);
use General;
use Cross_reference;
use AL_Profile_Gen;
use Upgrade;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_type  :shared;
my $region    :shared;
my $LightCalib    :shared; # Calibration scalar for lighting
my $AppCalib  :shared;     # Calibration scalar for appliances
my @BTypes    :shared;     # Array to hold all bulb categories
my $SetFile;               # Source file holding the list of houses [String]
our $occ_strt;             # HASH holding the active occupants at first timestep pdf
our $CREST;                # HASH holding CREST input data
our $light_sim;            # HASH holding lighting sim data
our $ColdApp;              # HASH to hold the cold appliance data
our $App;                  # HASH holding general appliance data
our $Activity;             # HASH holding the activity statistics
my $iThreads = 5;          # Number of threads

# --------------------------------------------------------------------
# Declare the local variables
# --------------------------------------------------------------------

my $hse_types;	    # declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	    # declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my @hse_TOT;        # Array to hold the list of all houses for region and type

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV < 3) {die "Three arguments are required: house_type region Source_list\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions) = &hse_types_and_regions_and_set_name(shift(@ARGV), shift(@ARGV));
my $Num_Keys = 0;
foreach my $stuff (keys (%{$hse_types})) {
    $hse_type = $hse_types->{$stuff};
    $Num_Keys++;
};
if($Num_Keys>1) {die "This script can only handle one house type at a time"};
    
$Num_Keys = 0;
foreach my $stuff (keys (%{$regions})) {
    $region = $regions->{$stuff};
    $Num_Keys++;
};
if($Num_Keys>1) {die "This script can only handle one region at a time"};

$SetFile = shift (@ARGV);
#if ($SetFile <=0) {die "Invalid energy consumption target $Target. Must be positive"};

# Load the set file
# Add full path to list
my $SetFilePath = "../../CityFiles/" . $SetFile;
open( my $fh, '<', $SetFilePath) or die "Can't read file '$SetFilePath' [$!]\n";
while (my $line = <$fh>) {
    # Read and process house number from file
    chomp $line;
    $line =~ s{\.[^.]+$}{}; # Remove extension from file name if any
    push(@hse_TOT, $line);
}
close $fh;

# --------------------------------------------------------------------
# Set the CREST input data
# --------------------------------------------------------------------
my $LogFile = $SetFile;
$LogFile =~ s{\.[^.]+$}{};
$LogFile = "$LogFile". "_" . $hse_type . "_" . "$region.log";
open(my $LogFH, '>', $LogFile) or die ("Can't open datafile: $LogFile");
SET_CREST: {
    my @CHREMBulbs = qw(Fluorescent Halogen Incandescent);
    # --------------------------------------------------------------------
    # Load in CHREM NN data
    # --------------------------------------------------------------------
    my $NNinPath = '../../NN/NN_model/ALC-Inputs-V2.csv';
    my $NNinput = &cross_ref_readin($NNinPath);
    
    # --------------------------------------------------------------------
    # Create an climate reference crosslisting hash
    # --------------------------------------------------------------------
    my $climate_ref = &cross_ref_readin('../../climate/Weather_HOT2XP_to_CWEC.csv');

    # --------------------------------------------------------------------
    # Load in the irradiance data
    # --------------------------------------------------------------------
    system ("printf \"Loading Irradiance data\"");
    my $IrrDir = "Global_Horiz/$region";
    opendir (DIR, $IrrDir) or die $!;
    while (my $file = readdir(DIR)) {
        if ($file =~ m/out$/) {
            my $irradiance = "Global_Horiz/$region/$file";
            my $Irr_ref = &GetIrradiance($irradiance); # Load the irradiance data
            my @Irr = @$Irr_ref;
            $CREST->{'Irradiance'}->{$file}=\@Irr;
        };
    };
    closedir(DIR);
    print " - Complete\n";

    # --------------------------------------------------------------------
    # Read the CSDDRD data for each record
    # --------------------------------------------------------------------
    system ("printf \"Gathering CSDDRD Data\"");
    my $record = '../../CSDDRD/2007-10-31_EGHD-HOT2XP_dupl-chk_A-files_region_qual_pref_' . $hse_type . '_subset_' . $region;
    my $exten = '.csv';
    my $CSDDRD; # declare a hash reference to store the CSDDRD data. This will only store one house at a time and the header data
    open (my $LIST, '<', $record . $exten) or die ("Can't open datafile: $record$exten");	# open readable file
    REC: while ($CSDDRD = &one_data_line($LIST, $CSDDRD)) {
        my $hse_name;
        FIND_REC: foreach my $Hse_rec (@hse_TOT) {
            if ($CSDDRD->{'file_name'} =~ /^$Hse_rec/) {
                # This CSDDRD record matches
                $hse_name = $Hse_rec;
                last FIND_REC;
            }
        }; # END FIND_REC
        if(not defined($hse_name)) {next REC}; # If there was no matching record, skip to next

        my $hse_occ; # Number of occupants in dwelling
        
        # --------------------------------------------------------------------
        # Find NN data
        # --------------------------------------------------------------------
        my $NNdata;
        if (exists $NNinput->{'data'}->{"$hse_name.HDF"}) {
            $NNdata = $NNinput->{'data'}->{"$hse_name.HDF"};
        } elsif (exists $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"}) {
            $NNdata = $NNinput->{'data'}->{"$hse_name.HDF.No-Dryer"};
        } else {
            #$issue++;
            #$return->{$hse_name}->{"$issue"} = "Error: Couldn't find NN record";
            #next RECORD;
            print $LogFH "Error: Couldn't find NN record for $hse_name\n";
            next REC;
        };
        # --------------------------------------------------------------------
        # Determine number of occupants
        # --------------------------------------------------------------------
        $hse_occ = $NNdata->{'Num_of_Children'}+$NNdata->{'Num_of_Adults'};
        if ($hse_occ>5) {   # WARN THE USER THE NUMBER OF OCCUPANTS EXCEEDS MODEL LIMITS
            #$issue++;
            #$return->{$hse_name}->{"$issue"} = "Warning: Occupants exceeded 5";
            #$hse_occ=5;
            print $LogFH "Warning: Occupants $hse_occ exceeded 5 for $hse_name\n";
            $hse_occ=5;
        };
        
        # --------------------------------------------------------------------
        # Determine number of bulbs/lamps in dwelling
        # --------------------------------------------------------------------
        my $iBulbs=0; # Number of bulbs/lamps for dwelling 
        foreach my $bulb (@CHREMBulbs) { # Read number of bulbs in dwelling from CHREM NN inputs
            $iBulbs = $iBulbs + $NNdata->{$bulb};
        };
        
        # --------------------------------------------------------------------
        # Get climate file for this house
        # --------------------------------------------------------------------
        my $loc = $climate_ref->{'data'}->{$CSDDRD->{'HOT2XP_CITY'}}->{'CWEC_FILE'};  # Determine climate for this dwelling
        $loc =~ s{\.[^.]+$}{}; # Remove extension
        $loc = $loc . '.out'; # Name of irradiance file
        
        # --------------------------------------------------------------------
        # Update the list and CREST inputs for the house
        # --------------------------------------------------------------------
        $CREST->{$hse_name}->{'Num_Occ'} = $hse_occ;
        $CREST->{$hse_name}->{'Irrad_file'} = $loc;
        $CREST->{$hse_name}->{'Num_Bulbs'} = $iBulbs;
        $CREST->{$hse_name}->{'data'}= dclone $NNdata; # All the NN data associtated with this record
        $CREST->{$hse_name}->{'stove_fuel'}=$CSDDRD->{'stove_fuel_use'}; # Fuel use: 1 = NG or propane, 2 = electricity
        $CREST->{$hse_name}->{'dryer_fuel'}=$CSDDRD->{'dryer_fuel_used'}; # Fuel use: 1 = NG or propane, 2 = electricity
    }; # END REC
    close $LIST;
    print " - Complete\n";
}; # END SET_CREST
close $LogFH;

# --------------------------------------------------------------------
# Load in CREST Databases
# --------------------------------------------------------------------
print "Reading in the occupant start state XML - ";
my $OccSTART = 'Occ_Lighting/occ_start_states.xml';
$occ_strt = XMLin($OccSTART);
print "Complete\n";

print "Reading in the light simulation parameters XML - ";
my $LIGHT = 'Occ_Lighting/lightsim_inputs.xml';
$light_sim = XMLin($LIGHT);
print "Complete\n";

foreach my $blb (keys (%{$light_sim->{'Types'}})) { # Read an store all bulb categories
    push(@BTypes,$blb);
};

# --------------------------------------------------------------------
# Load in cold appliance data
# --------------------------------------------------------------------
my $ColdFile = 'Appliance/Cold/Refrigerator_dist.xml';
$ColdApp->{'Refrigerator'}->{'dist'}=XMLin($ColdFile);
$ColdFile = 'Appliance/Cold/Refrigerator_eff.xml';
$ColdApp->{'Refrigerator'}->{'eff'}=XMLin($ColdFile);

$ColdFile = 'Appliance/Cold/Freezer_dist.xml';
$ColdApp->{'Freezer'}->{'dist'}=XMLin($ColdFile);
$ColdFile = 'Appliance/Cold/Freezer_eff.xml';
$ColdApp->{'Freezer'}->{'eff'}=XMLin($ColdFile);

# --------------------------------------------------------------------
# Load in general appliance data
# --------------------------------------------------------------------
my $AppFiles =  'Appliance/Appliance_inputs_CREST.xml';
$App = XMLin($AppFiles);

# -----------------------------------------------
# Load in the activity statistics
# -----------------------------------------------
print 'Loading the activity statistics';
my $ActStatpth = 'Appliance/activity_stats.csv';
$Activity = &ActiveStatParser($ActStatpth);
print " - Complete\n";

# -----------------------------------------------
# Set the Calibration scalars
# -----------------------------------------------
$LightCalib =$light_sim->{"_$region"}->{"_$hse_type"}->{'Calibration'};
$AppCalib = $App->{"_$region"}->{"_$hse_type"}->{'Calibration'};

# --------------------------------------------------------------------
# Start multithreading the profile generation
# --------------------------------------------------------------------
my $datestring = localtime();
print "Multithreading the process at $datestring\n";
START_MULT: {
    
    # Threading variables
    if ($iThreads<=0) {die "Number of threads cannot be less than 1\n"};
    my $iChunk = floor(($#hse_TOT+1)/$iThreads); # Number of houses sent to each thread
    my $thread;
    for(my $w=1; $w<=$iThreads; $w++){ # Multithread low
        my $end;
        my $start = $iChunk*($w-1);
        if ($w<$iThreads) {
            $end = ($iChunk*$w)-1;
        } else { # grab the last bit of the list
            $end = $#hse_TOT;
        };
        my @ShortList = @hse_TOT[ $start .. $end ];
        $thread->{"$w"} = threads->create(\&main,\@ShortList);
    };
    # Join the threads
    for(my $w=1; $w<=$iThreads; $w++){
        my $pass = $thread->{"$w"}->join();
    };
}; # END START_MULT
$datestring = localtime();
print "Finished profile generation on $datestring\n";

# --------------------------------------------------------------------
# Main calculation subroutine
# --------------------------------------------------------------------
sub main {

    my $list_ref = shift;
    my @houses = @$list_ref;
    #print "Light calibration $LightCalib\n";
    #print "Appliance calibration $AppCalib\n";
    
    my @Occ_keys=qw(zero one two three four five six);
    my $iHseCount = 0; # House counter

    # --------------------------------------------------------------------
    # Begin processing each house model for the region and house type
    # --------------------------------------------------------------------
    RECORD: foreach my $hse_name (@houses) {
        my @Occ; # Array to hold occupancy
        my $issue = 0;      # Issue counter
        my $hse_occ = $CREST->{$hse_name}->{'Num_Occ'};
        my $iBulbs = $CREST->{$hse_name}->{'Num_Bulbs'};
        my $loc = $CREST->{$hse_name}->{'Irrad_file'};
        my $Irr_ref = $CREST->{'Irradiance'}->{$loc};
        my @Irr = @$Irr_ref;
        my @Light; # Array to hold the total power draw of all lights [kW]
        my @TotalCold=(0) x 525600; # Array to hold the total power draw of all cold appliances [W]
        my @TotalOther=(0) x 525600; # Array to hold the total power draw of all other appliances [W]
        my @TotalCook=(0) x 525600; # Array to hold the annual power draw of range and oven (base electric) [W]
        my @TotalDry=(0) x 525600;; # Array to hold the annual power draw of dryer (base electric) [W]
        my @TotalALL=(0) x 525600; # Array to hold the total electrical power draw of ALL appliances [W]
        my $MeanActOcc=0;
        my $DayWeekStart = 4; # TODO: Determine day of the week

        # --------------------------------------------------------------------
        # Generate the occupancy profiles
        # --------------------------------------------------------------------
        my $IniState = &setStartState($hse_occ,$occ_strt->{'wd'}->{"$Occ_keys[$hse_occ]"}); # TODO: Determine 'we' or 'wd'
        my $Occ_ref = &OccupancySimulation($hse_occ,$IniState,$DayWeekStart); 
        @Occ = @$Occ_ref;
        
        # Determine the mean active occupancy
        foreach my $Step (@Occ) {
            if($Step>0) {$MeanActOcc++};
        };
        $MeanActOcc=$MeanActOcc/($#Occ+1); # Fraction of time occupants are active
        
        # --------------------------------------------------------------------
        # Generate Lighting Profile. NOTE: Returns kW
        # --------------------------------------------------------------------
        # --- Bulb data
        my @fBulbs = (); # Array to hold wattage of each bulb in the dwelling
        # Assign wattage for each bulb
        for (my $i=1;$i<=$iBulbs;$i++) { # Each bulb
            my $r1 = rand();
            my $cml=0;
            my $category;
            Category: foreach my $blb (@BTypes) { # Loop through each bulb category
                $cml=$cml+$light_sim->{'Types'}->{$blb}->{'Share'};
                if ($r1<=$cml) {
                    $category=$blb;
                    last Category;
                };
            }; # END Category
    
            # Reset variables
            $r1 = rand();
            $cml=0;
            my $BulbSubC;
            BulbSub: foreach my $blb (keys (%{$light_sim->{'Types'}->{$category}->{'sub'}})) { # Loop through each bulb sub-category
                $cml=$cml+$light_sim->{'Types'}->{$category}->{'sub'}->{$blb}->{'Share'};
                if ($r1<=$cml) {
                    $BulbSubC=$blb;
                    last BulbSub;
                };
            }; # END BulbSub
            if (not defined($BulbSubC)) {
                print "Category is $category\n";
                print "Random Number is $r1\n";
                print "Cumulative is $cml\n";
                die "Please check the distribution data";
            };
            # Store wattage of this bulb
            push(@fBulbs, $light_sim->{'Types'}->{$category}->{'sub'}->{$BulbSubC}->{'Wattage'});
        };
    
        # --- Call Lighting Simulation
        my $MeanThresh = $light_sim->{'threshold'}->{'mean'};
        my $STDThresh = $light_sim->{'threshold'}->{'std'};
        my ($light_ref,$AnnPow) = &LightingSimulation(\@Occ,\@Irr,\@fBulbs,$LightCalib,$MeanThresh,$STDThresh);
        @Light = @$light_ref; # [kW]

        # --------------------------------------------------------------------
        # Generate Cold appliance profiles
        # --------------------------------------------------------------------
        my $iNumColds=0;
        COLD: {
            my @Cold_key = qw(Main_Refrigerator Secondary_Refrigerator Main_Freezer Secondary_Freezer); # Keys for each type of cold appliance in NN inputs
            foreach my $cold (@Cold_key) { # Determine what cold appliances this dwelling has
                if ($CREST->{$hse_name}->{'data'}->{"$cold"} > 0) { # Dwelling has this type of cold appliance
                    $iNumColds++;
                    my $ColdSize = $CREST->{$hse_name}->{'data'}->{"$cold"}/28.316847; # Convert size to cu. ft
                    # Determine if fridge or freezer
                    my ($ColdType) = $cold =~ m/_(.*)/;
                    my ($Colduse) = $cold =~ m/(.*)_/;
                    my $ColdRef = $ColdApp->{"$ColdType"}; # Create a hash reference to the data
                    
                    # Randomly select appliance vintage from distribution
                    my $NumVint = $ColdRef->{'dist'}->{'Periods'}->{'intervals'}; # Number of vintage intervals
                    my $InterVint=1; # Index the vintage interval
                    my $fCumulativeP = 0;
                    my $fRand = rand();
                    COLD_VINT: while ($InterVint<=$NumVint) {
                        $fCumulativeP = $fCumulativeP +  $ColdRef->{'dist'}->{$Colduse}->{"_$region"}->{"_$InterVint"};
                        if ($fRand < $fCumulativeP) {last COLD_VINT};
                        $InterVint++;
                    }; # END COLD_VINT
                    my $vintage = &rand_range($ColdRef->{'dist'}->{'Periods'}->{"_$InterVint"}->{'min'},$ColdRef->{'dist'}->{'Periods'}->{"_$InterVint"}->{'max'});
                    
                    # Determine the corresponding UEC for this vintage and appliance type (Refrigerator,Chest_Freezer,Upright_Freezer)
                    my ($UEC,$cType) = &GetUEC($ColdType,$vintage,$ColdSize,$ColdRef->{'eff'});
                    
                    # Generate the annual appliance profile for this appliance (NOTE: The calibration scalar is not applied here)
                    my $CalibCyc = $App->{'Types_Cold'}->{$cType}->{'Base_cycles'}; # Calibrated mean cycles per year
                    my $Cold_Ref = &setColdProfile($UEC,$CalibCyc,$App->{'Types_Cold'}->{$cType}->{'Mean_cycle_L'},$App->{'Types_Cold'}->{$cType}->{'Restart_Delay'});
                    my @ThisCold = @$Cold_Ref;

                    # Update the total cold appliance power draw [W]
                    for (my $k=0; $k<=$#ThisCold;$k++) {
                        $TotalCold[$k]=$TotalCold[$k]+$ThisCold[$k];
                    };
                };
            };
        }; # END COLD
        
        # --------------------------------------------------------------------
        # Generate the profiles of all other appliances (except stove and dryer)
        # --------------------------------------------------------------------
        # Determine the appliance stock of this dwelling
        my @AppStock=();
        my $AppStock_ref = &GetApplianceStock($CREST->{$hse_name}->{'data'},$App->{'Ownership'}->{"_$region"});
        @AppStock=@$AppStock_ref;
        
        foreach my $item (@AppStock) { # For each appliance in the dwelling
            my $ThisApp_ref = &SetApplianceProfile(\@Occ,$MeanActOcc,$item,$App,$Activity,$AppCalib,$DayWeekStart);
            my @ThisApp = @$ThisApp_ref;

            # Update the TotalOther array [W]
            for(my $k=0;$k<=$#TotalOther;$k++) {
                $TotalOther[$k]=$TotalOther[$k]+$ThisApp[$k];
            };
        };

        # --------------------------------------------------------------------
        # Generate the electric profiles of the stove and dryer
        # --------------------------------------------------------------------
        my $nEStoves = 0; # Number of electric stoves
        if($CREST->{$hse_name}->{'data'}->{'Stove'} > 0){ # COOK: There is a stove, generate profile
            my $ref_CookStock = &GetStoveAppliances;
            my @CookStock=@$ref_CookStock;
            $nEStoves=1;
        
            foreach my $item (@CookStock) { # For each appliance in the dwelling
                my @ThisCook;
                if ($CREST->{$hse_name}->{'stove_fuel'} != 1) { # Stove is not natural gas/propane
                    my $ThisApp_ref = &SetApplianceProfile(\@Occ,$MeanActOcc,$item,$App,$Activity,$AppCalib,$DayWeekStart);
                    @ThisCook = @$ThisApp_ref; # [W]
                } else { # Stove is natural gas. Only consider standby power
                    my $iStandbyPower=$App->{'Types_Other'}->{$item}->{'Standby'}; # Standby power [W]
                    @ThisCook = ($iStandbyPower) x 525600;
                };

                # Update the TotalCook array [W]
                for(my $k=0;$k<=$#TotalCook;$k++) {
                    $TotalCook[$k]=$TotalCook[$k]+$ThisCook[$k];
                };
            };
        }; # END COOK
        my $nEDry = 0; # Number of electric stoves
        if($CREST->{$hse_name}->{'data'}->{'Clothes_Dryer'} > 0) { # DRY: If there is a dryer, generate the profile
            my $item = 'Clothes_Dryer_CREST';
            $nEDry = 1;
            # Call the appliance simulation
            if ($CREST->{$hse_name}->{'dryer_fuel'} != 1) { # Dryer is not natural gas/propane
                my $ThisApp_ref = &SetApplianceProfile(\@Occ,$MeanActOcc,$item,$App,$Activity,$AppCalib,$DayWeekStart);
                @TotalDry = @$ThisApp_ref; # [W]
            } else { # Dryer is natural gas/propane. Only consider the standby power
                my $iStandbyPower=$App->{'Types_Other'}->{$item}->{'Standby'}; # Standby power [W]
                @TotalDry=($iStandbyPower) x 525600;
            };
    
        }; # END DRY

        # --------------------------------------------------------------------
        # Sum lighting, cold, and other appliance vectors [W]
        # Set the base load of the dwelling [W]
        # Determine the annual energy consumption for the dwelling [kWh]
        # --------------------------------------------------------------------
        $AnnPow=0; # Rezero annual power
        my $ThisBase = 0.0; # Constant baseload power [W]
        #if($ThisBase>0) {
        #    my $ThisBaseStDev = $App->{"_$region"}->{"_$hse_type"}->{'BaseStdDev'}; # Constant baseload power standard deviation [W]
        #    $ThisBase = &GetMonteCarloNormalDistGuess($ThisBase,$ThisBaseStDev);
        #};
        #if($ThisBase<0) {$ThisBase=0};
        for(my $k=0;$k<=$#TotalOther;$k++) {                                
            $TotalALL[$k]=$TotalOther[$k]+$TotalCold[$k]+$TotalCook[$k]+$TotalDry[$k]+($Light[$k]*1000)+$ThisBase; # [W]
            $AnnPow=$AnnPow+((($TotalALL[$k]*60)/3600)/1000); # [kWh]
        };

        # --------------------------------------------------------------------
        # Print out the total power profile for the year
        # --------------------------------------------------------------------
        my $PrintOut = "AL_Elec_Tot_$hse_name.csv";
        open(my $Prof, '>', $PrintOut) or die ("Can't open datafile: $PrintOut");
        print $Prof "Occupants,$hse_occ,\n"; 
        print $Prof "Electric stoves,$nEStoves,\n"; 
        print $Prof "Electric Dryers,$nEDry,\n";
        print $Prof "Cold appliances, $iNumColds,\n";
        print $Prof "Annual non-HVAC,$AnnPow,kWh,\n";
        for(my $k=0;$k<=$#TotalOther;$k++) {
            print $Prof "$TotalALL[$k]\n";
        };
        close $Prof;

        $iHseCount++;
    }; # END RECORD

    # --------------------------------------------------------------------
    # Return number of houses processed
    # --------------------------------------------------------------------

    return($iHseCount);

}; # END sub main
