#!/usr/bin/perl

# ====================================================================
# Add_PV.pl
# Author: Adam Wills
# Date: Feb 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use CSV;	# CSV-2 (for CSV split and join, this works best)
use Data::Dumper;	# to dump info to the terminal for debugging purposes
use threads;	# threads-1.71 (to multithread the program)
use File::Copy;
use Math::Polygon;
use Math::Trig;
use Storable  qw(dclone);
use POSIX qw(ceil floor);

use lib qw(./modules);
use General;
use Cross_reference;
use PV;
use Upgrade;
use Database;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my @folders;	#declare an array to store the path to each hse which will be simulated
my @houses_desired = '.';
my @coord = ('x','y','z');
my @sides = ('base_frm', 'left_frm', 'top_frm', 'right_frm','PV_module','back_frm'); # surfaces of PV module

# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV == 0 || @ARGV == 3) {die "Four arguments are required: house_types regions set_name run_mode\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
}
else { # An inappropriate set_name was provided so die and leave a message
	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
};

my $run_mode = shift (@ARGV);
if ($run_mode !~ /[0-1]/) {die "Run mode can be (0 = create PV upgrade), (1= Undo upgrade) \n";}

if ($run_mode == 1) { # Scan set and undo upgrade
    print "Are you sure you want to run clean-up? \n";
    my $resp = <STDIN>;
    if ($resp !~ /Y|YES/i) {die;}
    foreach my $hse_type (values (%{$hse_types})) {
        foreach my $region (values (%{$regions})) {
            foreach my $file (<../$hse_type$set_name/$region/*>) {
                &clean_up_dir($set_name,$file);
            };
        };
    };
    die "Done clean-up, exiting\n";
};

# --------------------------------------------------------------------
# Read the PV parameters
# --------------------------------------------------------------------

my $PVkey = '../Input_upgrade/Input_PVv2.csv';
system ("printf \"Reading $PVkey\"");
# Open and read the crosslisting, note that the file handle below is a variable so that it simply goes out of scope
open (my $PVFILE, '<', $PVkey) or die ("can't open datafile: $PVkey");
my $PVdata;	# create an crosslisting hash reference
while (<$PVFILE>) {
	$_ = rm_EOL_and_trim($_);
	
	if ($_ =~ s/^\*header,//) {	# header row has *header tag, so remove this portion, and the key (first header value) leaving the CSV information
		$PVdata->{'header'} = [CSVsplit($_)];	# split the header into an array
	}
		
	elsif ($_ =~ s/^\*data,//) {	# data lines will begin with the *data tag, so remove this portion, leaving the CSV information
		@_ = CSVsplit($_);	# split the data onto the @_ array
		
		# create a hash slice that uses the header and data array
		# although this is a complex structure it simply creates a hash with an array of keys and array of values
		# @{$hash_ref}{@keys} = @values
		@{$PVdata}{@{$PVdata->{'header'}}} = @_;
	};
};
delete $PVdata->{'header'};
# notify the user we are complete and start a new line
print " - Complete\n";
close($PVFILE);
#print Dumper $PVdata;

# Check data
unless (defined ($PVdata->{'Vmpp'})) {
	die "The voltage at maximum power point is not defined! \n";
}
elsif ($PVdata->{'Vmpp'} <= 0) {
	die "The value of voltage at maximum power point is not correct! \n";
}
unless (defined ($PVdata->{'Isc'})) {
	die "The short-circuit current is not defined! \n";
}
elsif ($PVdata->{'Isc'} <= 0) {
	die "The short-circuit current value is not correct! \n";
}
if ($PVdata->{'gamma'} < 0) {
    print "WARNING: The Voc temperature coefficient (gamma) was entered as a negative value!\n";
    print"          ESP-r converts this coefficient to a negative internally. Sure $PVdata->{'gamma'}\n";
    print"          is the correct value you want to use?\n";
}
if ($PVdata->{'mis_factor'} < 0 || $PVdata->{'mis_factor'} > 1) {
	die "The efficiency shall be between 0 and 1! \n";
}
if ($PVdata->{'Area'} < 0 ) {
	die "The area [m2] needs to be greater than 0! \n";
}
if ($PVdata->{'Length'} < 0 || $PVdata->{'Width'} < 0 || $PVdata->{'Thick'} < 0) {
	die "PV module dimensions [m] need to be greater than 0! \n";
}
if ($PVdata->{'Max_Array_P'} < 0) {
	die "PV array maximum power [kW] output must be greater than 0! \n";
}
if ($PVdata->{'P_rated'} < 0) {
	die "PV panel rated power [W] must be greater than 0! \n";
}

# PV Mounting Parameters
# --------------------------------------
my $AzMin = $PVdata->{'AzMin'}; # Minimum azimuth angle to allow PV mounting on the surface [deg]
my $AzMax = $PVdata->{'AzMax'}; # Maximum azimuth angle to allow PV mounting on the surface [deg]
my $SA_Usable = $PVdata->{'SA_Usable'}; # Percentage of surface area that is usable

if ($AzMin < 0 || $AzMax < 0 || $AzMin > 360 || $AzMax > 360) {
    die "Mounting angles for PV outside acceptable range! \n";
} elsif ($AzMin > $AzMax) {
    die "Minumum mounting angle for PV cannot be greater than maximum angle\n!";
};

if ($SA_Usable > 1) {
    die "Usable surface area ratio cannot be greater than 1!\n";
};

# --------------------------------------------------------------------
# Read the PV inverter parameters
# --------------------------------------------------------------------
my $Intertkey = '../Input_upgrade/Input_Inverter.xml';
my $Inverter_data = &key_XML_readin($Intertkey, [1]);

# -----------------------------------------------
# Declare important variables for file generation
# -----------------------------------------------
my $zone_extensions = ['con', 'geo', 'opr', 'tmc','htc','spm'];	# extentions that are used for individual zones

# -----------------------------------------------
# Develop the ESP-r databases and cross reference keys
# -----------------------------------------------
my ($mat_data, $con_data, $optic_data, $cfc_data, $pln_data) = &database_XML();	# construct the databases and leave the information loaded in the variables for use in house generation

# -----------------------------------------------
# Read in the templates
# -----------------------------------------------
my $template;	# declare a hash reference to hold the original templates for use with the generation house files for each record

# Open and read the template files
foreach my $ext (@{$zone_extensions}) {	# do for each filename extention
	my $file = "../templates/template.$ext";
	# note that the file handle below is a variable so that it simply goes out of scope
	open (my $TEMPLATE, '<', $file) or die ("can't open template: $file");	# open the template
	$template->{$ext} = [<$TEMPLATE>];	# Slurp the entire file with one line per array element
    close ($TEMPLATE);
};

# hash reference to store encountered issues during the house builds
my $issues;

# -----------------------------------------------
# Report Data
# -----------------------------------------------
my $RepHeader = ['surface_area', 'slope','azimuth','PV_area','Num_modules','Surf_Coverage']; # Header items for report
my $RepData; # Declare HASH to hold report data

my $ResFname = "../summary_files/Add_PV$set_name" . '_Houses.csv';

# Examine the summary files directory, if add PV exists, issue error and terminate
foreach my $file (<../summary_files/*>) {
	if ($file =~ /$ResFname/) {
        die ("ERROR: PV Upgrade for set $set_name exists. Terminating");
    };
};

# --------------------------------------------------------------------
# Begin multi-threading for regions and house types
# --------------------------------------------------------------------
MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
            
            foreach my $issue_key (keys (%{$thread_return->{$hse_type}->{$region}->{'issues'}})) {
				my $issue = $thread_return->{$hse_type}->{$region}->{'issues'}->{$issue_key};
				foreach my $problem (keys (%{$issue})) {
					$issues->{$issue_key}->{$problem}->{$hse_type}->{$region} = $issue->{$problem}->{$hse_type}->{$region};
				};
			};
            
            foreach my $PV_key (keys (%{$thread_return->{$hse_type}->{$region}->{'PV_Upgrade'}})) {
				$RepData->{$hse_type}->{$region} = $thread_return->{$hse_type}->{$region}->{'PV_Upgrade'};
			};
            
            
        };
    };
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        
        my $hseRepData; # Hold the PV report data
        
        push (my @dirs, <../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        # print Dumper @dirs;
        
        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        
        EACHHSE: foreach my $dir (@dirs) {
         
            my $hse_name = $dir;
            my $Roof_type;
            my $hse_file;	# new hash reference to the ESP-r files for this record
            # house file coordinates to print when an error is encountered
			my $coordinates;
            my $Num_zones = 0;
        
            # Determine the house name
            $hse_name =~ s{.*/}{};
            $hse_name =~ s/_[0-9]+//; 	 # Clean up house name if duplicate	
            $coordinates = {'hse_type' => $hse_type, 'region' => $region, 'file_name' => $hse_name};
            # TODO: If a .spm file exists, die
            if($hse_name =~ m/^(BCD)/) {next EACHHSE};
            
            # Find all the geometry files for the model
            my @files = glob "$dir/*.geo";
            for (0..$#files){
                $files[$_] =~ s/\.geo$//; # Remove geo extension
                $files[$_] =~ s/.*\.//; # Remove house prefix and path
            };
            
            # Determine if an attic or roof
            foreach my $zone (@files) {
                $Num_zones++;
                if($zone =~ m/(attic|roof)/i) {$Roof_type = $zone};
            };
            if( length $Roof_type ) {
                # TODO: Error Handling, no roof type
            };

            # If $zone='roof', skip this house as it has a flat roof
            if($Roof_type =~ m/(roof)/i) {
                print "$hse_name has a flat roof, skipping to next house\n";
                foreach my $item (@{$RepHeader}) {	#  Set report values
                    $hseRepData->{$hse_name}->{'flat_roof'}->{$item}=0;
                };
                # RECORD AREA OF FLAT ROOF
                #TODO: Record that house is ineligible for PV
                last EACHHSE;
            };

            foreach my $ext (@{$zone_extensions}) {
                $hse_file->{$ext} = [@{$template->{$ext}}];	# create the template file for the zone
			};
            
            # --------------------------------------------------------------------
            # Interrogate the geometry file
            # --------------------------------------------------------------------
            my $GeoPath = $dir . "/" . $hse_name . "." . $Roof_type . ".geo"; # Path to roof/attic geo file
            my $OldGeo;
            open $OldGeo, $GeoPath or die "Could not open $GeoPath\n";
            
            my @lines = <$OldGeo>; # Pull entire file into an array
            my $counter=0; # initialize counter, used to index lines in file
            
            ORIENT: { # Find model angle of rotation
                my $past=1; # counter to skip over .geo description line
                foreach my $line (@lines) {
                    if ($line !~ m/^(#)/i) { # Not a commented line
                        if ($past < 2) {
                            $past++; 
                        } else {
                            last ORIENT;
                        };    
                    };
                    $counter++;
                };
            }; # END: ORIENT
            
            my @tokens = split ' ', $lines[$counter];
            my $NumVert = $tokens[0]; # Number of vertices
            my $NumSurf = $tokens[1]; # Number of surfaces
            my $AngRot = $tokens[2];  # Angle of rotation
            @tokens = (); # Clear array
            $counter++; # Advance to next line
            
            # Read and store vertex data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $vertex; # HASH to hold vertex info
            my $stop = $NumVert+$counter;
            my $Vert = 1;
            while ($counter < $stop) {
                my @tokens = split ' ', $lines[$counter];
                my $rec = {};
                $vertex->{$Vert} = $rec;
                my $j = 0;
                foreach my $coord (@coord) {
                    $rec->{$coord} = $tokens[$j];
                    $j++;
                };
                $counter++;
                $Vert++;
            };
            

            # Read and store surface geometry data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $surf; # HASH to hold surface info
            my $sNum = 1;
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                my $rec = {};
                $surf->{$sNum} = $rec; # Surface number
                $rec->{'num_vert'}= $tokens[0]; # Number of vertices that defines this surface
                my $nV = $tokens[0];
                $rec->{'name'}= $tokens[($nV+2)]; # Name of surface
                
                # Store vertexes that make up surface
                my $subRec = {};
                $surf->{$sNum}->{'vert_lst'} = $subRec;
                for (my $j=1; $j <= $nV; $j++) {
                    $subRec->{$j} = $tokens[$j]
                };
                $counter++;
                $sNum++;
            };
            
            # Read and store construction data
            my $past = 1;
            while ($lines[$counter] =~ m/^(#)/i || $past < 4) { # Skip over comments
                if ($lines[$counter] !~ m/^(#)/i) {$past++}; # Line is no commented, but don't need this data
                $counter++;
            };
            $sNum = 1; # Surface indexer
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                $surf->{$sNum}->{'con'}= $tokens[4]; # surface construction
                $counter++;
                $sNum++;
            };
            
            close $OldGeo;
            
            # --------------------------------------------------------------------
            # Determine eligible surfaces for PV
            # --------------------------------------------------------------------

            # Only surfaces with construction type 'slop'
            # my $PVZoneCount=0; # Counter for the number of PV zones
            # Initialize HASH to hold PV geometry and data
            my $PVZones;
            foreach my $index (keys (%{$surf})) {
                if ($surf->{$index}->{'name'} !~ m/^(floor|ceiling)/i && $surf->{$index}->{'con'} =~ m/(slop)$/i) { # surface is not a floor or ceiling, and is sloped
                    
                    my @P = (); # Array to hold coordinates of vertices 
                    # Determine Cartesian coordinates of all points that define the surface
                    for (my $i = 1; $i <= $surf->{$index}->{'num_vert'}; $i++) {
                        my $VertNumber = $surf->{$index}->{'vert_lst'}->{$i};
                        foreach my $point (@coord) {
                            push(@P, $vertex->{$VertNumber}->{$point});
                        };
                    };

                    # Determine surface orientation # CHECK SURFACE 0 < SLOPE < 90 AND 90 < AZIMUTH < 270
                    # Isolate first 3 points
                    my @p1=();
                    my @p2=();
                    my @p3=();
                    my $j=0;
                    while ($j < 3) {
                        push(@p1,$P[$j]);
                        $j++;
                    };
                    while ($j < 6) {
                        push(@p2,$P[$j]);
                        $j++;
                    };
                    while ($j < 9) {
                        push(@p3,$P[$j]);
                        $j++;
                    };
                    
                    my ($Slope,$Azimuth, $n_ref) = &surf_slope_azimuth($AngRot,\@p1,\@p2,\@p3);
                    my @n = @$n_ref; # Normal vector of surface, magnitude 1, unrotated
                    my ($poly, $shape,$length_r) = &poly_obj(\@P,\@n,$surf->{$index}->{'num_vert'});
                    my @lengths = @$length_r;
                    my $area = $poly->area;
                    my $NumColl=0; # Number of collectors that can fit onto the surface
                    
                    # Determine if the surface is eligible for PV
                    if ($area > $PVdata->{'Area'} && $Azimuth >= $AzMin && $Azimuth <= $AzMax && $Slope < 90) {
                        if ($shape =~ m/^(rect)/i) { # surface geometry is rectangular
                            # Call bin packing algorithm
                            $NumColl=&rect_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                            #print "Number of collectors is $NumColl\n";
                            #sleep;
                        } elsif ($shape =~ m/^(trap)/i) { # surface geometry is rectangular
                            $NumColl=&trap_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } elsif ($shape =~ m/^(tri)/i) { # surface geometry is triangular
                            $NumColl=&tri_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } else {
                            # TODO: ERROR HANDLING
                        };
                    };
                    
                    if ($NumColl > 0) { # Collectors may be placed on this surface
                        my $Coverage = ($NumColl*$PVdata->{'Area'})/$area;

                        if ($SA_Usable < 1 && $Coverage > $SA_Usable) { # Check to see if number of collectors needs to be reduced
                            $NumColl = floor(($SA_Usable*$area)/$PVdata->{'Area'});
                            #$Coverage = ($NumColl*$PVdata->{'Area'})/$area;
                        };

                        $PVZones->{$surf->{$index}->{'name'}}->{'Area'} = $NumColl*($PVdata->{'Area'});
                        $PVZones->{$surf->{$index}->{'name'}}->{'Slope'} = $Slope;
                        $PVZones->{$surf->{$index}->{'name'}}->{'Azimuth'} = $Azimuth;
                        $PVZones->{$surf->{$index}->{'name'}}->{'NumColl'} = $NumColl;
                        
                        # Add report data
                        $hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'surface_area'}=sprintf("%4.3f",$area);
                        $hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'slope'}=sprintf("%4.3f",$Slope);
                        $hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'azimuth'}=sprintf("%4.3f",$Azimuth);
                        #$hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'PV_area'}=sprintf("%4.3f",$NumColl*$PVdata->{'Area'});
                        #$hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'Num_modules'}=sprintf("%d",$NumColl);
                        #$hseRepData->{$hse_name}->{$surf->{$index}->{'name'}}->{'Surf_Coverage'}=sprintf("%4.3f",$Coverage);
                        #$PVZoneCount++;
                    };
                };
            };

            # --------------------------------------------------------------------
            # Adjust number of collectors based on max. allowable power rating
            # --------------------------------------------------------------------
            if ($PVZones) {
                if ($PVdata->{'Max_Array_P'} > 0) {
                    my $PVTotPower=0;
                    my $FindMax->{'MaxVal'} = 0;
                    foreach my $index (keys (%{$PVZones})) {
                        my $ArrayPow = $PVZones->{$index}->{'NumColl'}*$PVdata->{'P_rated'};
                        $PVTotPower = $PVTotPower+$ArrayPow;
                        if ($ArrayPow > $FindMax->{'MaxVal'}) {
                            $FindMax->{'MaxVal'} = $ArrayPow;
                            $FindMax->{'name'} = $index;
                        };
                    };
                    if ($PVTotPower > $PVdata->{'Max_Array_P'}) { # Arrays for house exceed max allowable production, reduce number of panels
                        # Determine number of collectors to be reduced
                        my $NumReduce = -1*ceil(($PVTotPower-$PVdata->{'Max_Array_P'})/$PVdata->{'P_rated'});

                        #print "WARNING: All collectors removed from surface $FindMax->{'name'}, house $hse_name\n";
                        PVREMOVE: {
                            foreach my $index (keys (%{$PVZones})) {
                                if ($PVZones->{$index}->{'NumColl'} > 0) { # Surface contains collectors
                                    if ($PVZones->{$index}->{'Azimuth'} <= 135 || $PVZones->{$index}->{'Azimuth'} >= 225) { # Less than ideal, remove
                                        $PVZones->{$index}->{'NumColl'} = $PVZones->{$index}->{'NumColl'}+$NumReduce;
                                        if ($PVZones->{$index}->{'NumColl'} < 0) { # There is still too many collectors
                                            $NumReduce = $PVZones->{$index}->{'NumColl'};
                                        } else {
                                            last PVREMOVE;
                                        };
                                    };
                                };
                            };
                            # If this spot has been reached, there is still too many collectors
                            FINALSWEEP: {
                                foreach my $index (keys (%{$PVZones})) {
                                    if ($PVZones->{$index}->{'NumColl'} > 0) { # Remove some collectors from this surface
                                        $PVZones->{$index}->{'NumColl'} = $PVZones->{$index}->{'NumColl'}+$NumReduce;
                                        if ($PVZones->{$index}->{'NumColl'} < 0) { # There is still too many collectors
                                            $NumReduce = $PVZones->{$index}->{'NumColl'};
                                        } else {
                                            last FINALSWEEP;
                                        };
                                    }
                                };
                            
                            } # END FINALSWEEP
                        }; # END PVREMOVE
                    };
                };
                
                # If surfaces have no collectors, remove them
                foreach my $PVsurfaces (keys (%{$PVZones})) {
                    if ($PVZones->{$PVsurfaces }->{'NumColl'} <= 0) {
                        delete $PVZones->{$PVsurfaces};
                        delete $hseRepData->{$hse_name}->{$PVsurfaces};
                    };
                };
                my $hashCount = keys %{$PVZones};
                if ($hashCount <= 0) { # All collectors removed
                    undef $PVZones;
                };
   
            };
            
            if (!$PVZones) { # No surfaces were eligible for PV
                foreach my $item (@{$RepHeader}) {	#  Set report values
                    $hseRepData->{$hse_name}->{'no_eligible'}->{$item}=0;
                };
                last EACHHSE; # MOVE TO NEXT RECORD
            };

            # --------------------------------------------------------------------
            # Store additional report data for house PV upgrade
            # --------------------------------------------------------------------
            foreach my $PVsurfaces (keys (%{$PVZones})) {
                my $Coverage = ($PVZones->{$PVsurfaces}->{'NumColl'}*$PVdata->{'Area'})/$hseRepData->{$hse_name}->{$PVsurfaces}->{'surface_area'};

                $hseRepData->{$hse_name}->{$PVsurfaces}->{'PV_area'}=sprintf("%4.3f",$PVZones->{$PVsurfaces}->{'NumColl'}*$PVdata->{'Area'});
                $hseRepData->{$hse_name}->{$PVsurfaces}->{'Num_modules'}=sprintf("%d",$PVZones->{$PVsurfaces}->{'NumColl'});
                $hseRepData->{$hse_name}->{$PVsurfaces}->{'Surf_Coverage'}=sprintf("%4.3f",$Coverage);
                
            };

            # --------------------------------------------------------------------
            # Load and begin manipulating model files
            # --------------------------------------------------------------------
            
            # Load in building files to be updated
             foreach my $ext (qw(cfg cnn elec afn ctl)) {
                my $FILEpath = $dir . "/" . $hse_name . ".$ext"; # Path to cfg file
                open (my $FILEid, '<', $FILEpath) or die ("can't open file: $FILEpath");
                $hse_file->{$ext} = [<$FILEid>];	# Slurp the entire file with one line per array element
                close $FILEid;
                # Create backups of old files
                rename $FILEpath, "$FILEpath.old";
                unlink $FILEpath;
            };

            my $PVZoneCount = keys %{$PVZones};
            my $Num_new=$Num_zones+$PVZoneCount; # Update number of zones in cfg file
            &replace ($hse_file->{'cfg'}, "#ZONE_COUNT: no of zones", 1, 1, "%s\n", "$Num_new");


            # Add an AC grid node with variable voltage
            my $NumEnodes=1; # Base CHREM models should only have one node
            # Record Number of power only components
            my $NumPowOnly;
            for (my $i=0;$i<=$#{$hse_file->{'elec'}};$i++) {
                if (${$hse_file->{'elec'}}[$i] =~ m/(#NUM_POWER_ONLY_COMPONENTS)/) {
                    $NumPowOnly = @{$hse_file->{'elec'}}[$i+1];
                    last;
                };
            };
            # ADW Apr 29, 2015: Removed grid node from electrical network
            #$NumEnodes++;
            #my $GridNode = $NumEnodes; # Store index of the grid node
            #&insert ($hse_file->{'elec'}, "#END_NODES_DATA", 1, 0, 0, "%s\n", "    $NumEnodes  Grid          1-phase         1  variable          240.00    0"); # Grid node
            #
            ## Link Grid node to AC BUS
            #&replace ($hse_file->{'elec'}, "#BEGIN_CONNECTING_COMPONENTS", 1, 1, "%s\n", "    1 # Number of components");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "# Index db  Component     Phase"); # Wire to connect house AC bus to Grid
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "#       ref name          type");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "    1    2  To_grid       1-phase");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "  Lossless wire to connect house to grid");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "# Number of additional data items:");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "    6");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTING_COMPONENTS", 1, 0, 0, "%s\n", "    0.0000        0.0000        0.0000        0.0000        0.0000        1.0000");
            #
            #&replace ($hse_file->{'elec'}, "#BEGIN_CONNECTIONS", 1, 1, "%s\n", "    1");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTIONS", 1, 0, 0, "%s\n", "# Connection        Phases  Connection  Start nodes       End nodes"); #Define connection between the nodes
            #&insert ($hse_file->{'elec'}, "#END_CONNECTIONS", 1, 0, 0, "%s\n", "# Index type        1 2 3   component   pha1 pha2 pha3    pha1 pha2 pha3");
            #&insert ($hse_file->{'elec'}, "#END_CONNECTIONS", 1, 0, 0, "%s\n", "    1  1-phase      1 0 0     1         1    0    0       $NumEnodes    0    0");

            # --------------------------------------------------------------------
            # Begin generating PV Zones
            # --------------------------------------------------------------------
            my $CurrZone = $Num_zones; # Indexer to hold current zone number
            my $NewSurfaces = 0; # Counter to hold number of new surfaces
            foreach my $PVName (keys (%{$PVZones})) {
                $CurrZone++;
                my $ZoneName = "$PVName" . '_PV';
                my $PArea = $PVZones->{$PVName}->{'Area'};
                my $PSlope = $PVZones->{$PVName}->{'Slope'};
                my $PAzim = 360-$PVZones->{$PVName}->{'Azimuth'}; # Rotation is CCW
                my $PVol = $PVZones->{$PVName}->{'Area'}*$PVdata->{'Thick'};
                $PVol = sprintf("%4.1f",$PVol);
                
                # Add zone entry to cfg
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*zon $CurrZone");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*opr ./$hse_name.$ZoneName.opr");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*geo ./$hse_name.$ZoneName.geo");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*con ./$hse_name.$ZoneName.con");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*tmc ./$hse_name.$ZoneName.tmc");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*ihc ./$hse_name.$ZoneName.htc");
                &insert ($hse_file->{'cfg'}, "#END_ZONES", 1, 0, 0, "%s\n", "*zend");
                
                # Add entry to afn
                &insert ($hse_file->{'afn'}, "#END_NODES", 1, 0, 0, "%s\n", "$ZoneName 1 0 1.2 20.0 0 $PVol");
                
                # Create zone files
                foreach my $ext (qw(opr con geo tmc htc)) {
					&copy_template($ZoneName, $ext, $hse_file, 0);
				};
                
                
                
                $PAzim = sprintf("%d", $PAzim);
                
                &replace ($hse_file->{"$ZoneName.geo"}, "#ZONE_NAME", 1, 1, "%s\n", "GEN $ZoneName This file describes the ficticious $ZoneName");	# set the name at the top of each zone geo file
                &replace ($hse_file->{"$ZoneName.geo"}, "#VER_SUR_ROT", 1, 1, "%u %u %u\n", 8, 6, $PAzim); # Set number of zone vertices and surfaces, and orientation
                
                # SET THE ORIGIN AND MAJOR VERTICES OF THE ZONE (note the formatting), Set PV 20 m north of origin
                
                # Store base vertices
                my $x1 = sqrt($PArea)/2;	
				my $x2 = -1*$x1;
				my $y1 = sprintf("%6.2f", 20);
				my $y2 = 20-cos(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
				my $z1 = sin(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
				my $z2 = sprintf("%6.3f", 0);
                # Formatting
                $x1 = sprintf("%6.2f", $x1);
                $z1 = sprintf("%6.3f", $z1); 
                $x2 = sprintf("%6.2f", $x2);
                $y2 = sprintf("%6.2f", $y2);

                push (@{$PVZones->{$PVName}->{'vertices'}->{'base'}},	# base vertices in CCW (looking down)
				"$x1 $y1 $z1", "$x2 $y1 $z1", "$x2 $y2 $z2", "$x1 $y2 $z2");
                            
                # Store top vertices
				my $y3 = 20-sqrt($PArea)*cos(deg2rad($PSlope));
                my $y4 = $y3-cos(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
                my $z3 = (sin(deg2rad($PSlope))*sqrt($PArea))+(sin(deg2rad(90-$PSlope))*$PVdata->{'Thick'});
                my $z4 = sin(deg2rad($PSlope))*sqrt($PArea);
                # Formatting
                $y3 = sprintf("%6.2f", $y3);
                $y4 = sprintf("%6.2f", $y4);
                $z3 = sprintf("%6.3f", $z3);
                $z4 = sprintf("%6.3f", $z3);
                
                push (@{$PVZones->{$PVName}->{'vertices'}->{'top'}},	# top vertices in CCW (looking down)
				"$x1 $y3 $z3", "$x2 $y3 $z3", "$x2 $y4 $z4", "$x1 $y4 $z4");
                
                # Create the .geo and .con files
                # --------------------------------------------------------------------
                my $vertex_count = 0;
                foreach my $wSurf ('base', 'top') {
					# loop over the vertices in the array
					foreach my $verte (0..$#{$PVZones->{$PVName}->{'vertices'}->{$wSurf}}) {
						# increment the counter
						$vertex_count++;
						# insert the vertex with some information
						&insert ($hse_file->{"$ZoneName.geo"}, "#END_VERTICES", 1, 0, 0, "%s # %s%u; %s\n", $PVZones->{$PVName}->{'vertices'}->{$wSurf}->[$verte], "$wSurf v", $verte + 1, "total v$vertex_count");
					};
				};
                
                # Begin defining PV module surface attributes, update 
                my $surface_index = 1;
                my $em_abs; # store the solar absorbtivity and IR emissivity
                my @tmc_type;	# initialize arrays to hold optical reference data
				my $tmc_flag = 0; # to note if real optics are present
                
                foreach my $wSurf (@sides) {
                    my $con = \%{$PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'con'}};
                    if ($wSurf =~ /frm/i && $wSurf !~ /base/i) { # Side frame of the PV
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'OPAQ', 'VERT', 'PV_frame', 'EXTERIOR'];
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'orientation'} = 'VERT';
                    } elsif ($wSurf =~ /base/i) { # Back of the PV
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'OPAQ', 'SLOP', 'PV_frame', 'EXTERIOR'];
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'orientation'} = 'SLOP';
                    } else { # It's the PV surface
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'TRAN', 'SLOP', 'PV_top', 'EXTERIOR'];
                        $PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'orientation'} = 'SLOP';
                    };
                    &insert ($hse_file->{"$ZoneName.geo"}, '#END_SURFACE_ATTRIBUTES', 1, 0, 0, "%3s, %-13s %-5s %-5s %-12s %-15s\n", @{$PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'}});
                    
                    # Begin updating constructions file info
                    if ($wSurf =~ /frm/i) {  # surface is PV frame
                        $con->{'name'} = 'PV_frame';
                    } else {  # it's the PV surface
                        $con->{'name'} = 'PV_top';
                    };
                    
                    
                    # Add layer data
                    # don't check the RSI as it was already set by the previous zone's surface
					con_surf_PV(0, $ZoneName, $wSurf,$PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'con'},$issues,$coordinates);

                    my $gaps = 0;	# holds a count of the number of gaps
					my @pos_rsi;	# holds the position of the gaps and RSI
					my $layer_count = 0;
					my $U_final = 'unknown';
                    if ($con->{'RSI_final'} > 0) {$U_final= sprintf("%.3f", 1 / $con->{'RSI_final'});};
                    
                    &insert ($hse_file->{"$ZoneName.con"}, "#END_PROPERTIES", 1, 0, 0, "#\n%s\n", "# CONSTRUCTION: $wSurf - $con->{'name'} - RSI orig $con->{'RSI_orig'} final $con->{'RSI_final'} expected $con->{'RSI_expected'} - U Value final $U_final (W/m^2K) - $con->{'description'} ");
                    
                    foreach my $layer (@{$con->{'layers'}}) { # Add all the layers to the construction file

						$layer_count++;
						my $mat = $layer->{'mat'};
						
						if ($mat eq 'Gap') {
							$gaps++;
							my $U_val = 'unknown';
							if ($layer->{'gap_RSI'}->{'vert'} > 0) {$U_val= sprintf("%.3f", 1 / $layer->{'gap_RSI'}->{'vert'});};
							push (@pos_rsi, $layer_count, $layer->{'gap_RSI'}->{'vert'});	# FIX THIS LATER SO THE RSI IS LINKED TO THE POSITION (VERT, HORIZ, SLOPE)
							&insert ($hse_file->{"$ZoneName.con"}, "#END_PROPERTIES", 1, 0, 0, "%s %s %s\n", "0 0 0", $layer->{'thickness_mm'} / 1000, "0 0 0 0 # $layer->{'component'} - $mat; RSI = $layer->{'gap_RSI'}->{'vert'}; U value = $U_val (W/m^2K)");	# add the surface layer information
						}
						elsif (defined ($layer->{'conductivity_W_mK_orig'})) {
							my $RSI = $layer->{'thickness_mm'} / 1000 / $layer->{'conductivity_W_mK'};
							my $U_val = 'unknown';
							if ($RSI > 0) {$U_val= sprintf("%.3f", 1 / $RSI);};
							$RSI = sprintf("%.1f", $RSI);
							&insert ($hse_file->{"$ZoneName.con"}, "#END_PROPERTIES", 1, 0, 0, "%s %s %s\n", "$layer->{'conductivity_W_mK'} $layer->{'density_kg_m3'} $layer->{'spec_heat_J_kgK'}", $layer->{'thickness_mm'} / 1000, "0 0 0 0 # $layer->{'component'} - $mat; $layer->{'component'} ; conductivity_W_mK - orig: $layer->{'conductivity_W_mK_orig'} final: $layer->{'conductivity_W_mK'}; RSI = $RSI; U value = $U_val (W/m^2K)");
						}
						else {
							my $RSI = $layer->{'thickness_mm'} / 1000 / $layer->{'conductivity_W_mK'};
							my $U_val = 'unknown';
							if ($RSI > 0) {$U_val= sprintf("%.3f", 1 / $RSI);};
							$RSI = sprintf("%.1f", $RSI);
							&insert ($hse_file->{"$ZoneName.con"}, "#END_PROPERTIES", 1, 0, 0, "%s %s %s\n", "$layer->{'conductivity_W_mK'} $layer->{'density_kg_m3'} $layer->{'spec_heat_J_kgK'}", $layer->{'thickness_mm'} / 1000, "0 0 0 0 # $layer->{'component'} - $mat; RSI = $RSI; U value = $U_val (W/m^2K)");
						};	# add the surface layer information
                    };
                    
                    &insert ($hse_file->{"$ZoneName.con"}, "#END_LAYERS_GAPS", 1, 0, 0, "%s\n", "$layer_count $gaps # $wSurf $con->{'name'}");
                    
                    if ($con->{'type'} eq "OPAQ") { push (@tmc_type, 0);}
					elsif ($con->{'type'} eq "TRAN") {
						push (@tmc_type, $con->{'optic_name'});
						$tmc_flag = 1;
					};
                    if (@pos_rsi) {
						&insert ($hse_file->{"$ZoneName.con"}, "#END_GAP_POS_AND_RSI", 1, 0, 0, "%s\n", "@pos_rsi # $wSurf $con->{'name'}");
					};
                    
                    push (@{$em_abs->{'em'}->{'inside'}}, $mat_data->{$con->{'layers'}->[$#{$con->{'layers'}}]->{'mat'}}->{'emissivity_in'});
					push (@{$em_abs->{'em'}->{'outside'}}, $mat_data->{$con->{'layers'}->[0]->{'mat'}}->{'emissivity_out'});
					push (@{$em_abs->{'abs'}->{'inside'}}, $mat_data->{$con->{'layers'}->[$#{$con->{'layers'}}]->{'mat'}}->{'absorptivity_in'});
					push (@{$em_abs->{'abs'}->{'outside'}}, $mat_data->{$con->{'layers'}->[0]->{'mat'}}->{'absorptivity_out'});
                    
                    # Add connection for this surface
                    &insert ($hse_file->{'cnn'}, "#END_CONNECTIONS", 1, 0, 0, "%s\n", "$CurrZone $surface_index 0 0 0 # $ZoneName $wSurf facing exterior (EXTERIOR)");
                    
                    if ($wSurf !~ /frm/i) {  # surface is the PV, store zone and surface number
                        $PVZones->{$PVName}->{'ZoneInd'} = $CurrZone;
                        $PVZones->{$PVName}->{'SurfInd'} = $surface_index;
                    };

                    $surface_index++;
                    $NewSurfaces++;

                };
                
                
                &insert ($hse_file->{"$ZoneName.con"}, "#EM_INSIDE", 1, 1, 0, "%s\n", "@{$em_abs->{'em'}->{'inside'}}");	# write out the emm/abs of the surfaces for each zone
				&insert ($hse_file->{"$ZoneName.con"}, "#EM_OUTSIDE", 1, 1, 0, "%s\n", "@{$em_abs->{'em'}->{'outside'}}");
				&insert ($hse_file->{"$ZoneName.con"}, "#SLR_ABS_INSIDE", 1, 1, 0, "%s\n", "@{$em_abs->{'abs'}->{'inside'}}");
				&insert ($hse_file->{"$ZoneName.con"}, "#SLR_ABS_OUTSIDE", 1, 1, 0, "%s\n", "@{$em_abs->{'abs'}->{'outside'}}");

                # Define PV module surface vertices
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'base_frm'}->{'vertices'}},1,4,3,2);
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'left_frm'}->{'vertices'}},2,3,7,6);
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'top_frm'}->{'vertices'}},5,6,7,8);
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'right_frm'}->{'vertices'}},1,5,8,4);
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'PV_module'}->{'vertices'}},1,2,6,5);
                push(@{$PVZones->{$PVName}->{'surfaces'}->{'back_frm'}->{'vertices'}},4,8,7,3);
                
                # Add surface vertex info to the .geo file
                foreach my $wSurf (@sides) {
                    &insert ($hse_file->{"$ZoneName.geo"}, '#END_SURFACES', 1, 0, 0, "%u %s # %s\n", '4', "@{$PVZones->{$PVName}->{'surfaces'}->{$wSurf}->{'vertices'}}", $wSurf);
                };
                
                # fill out the unused and indentation indexes with array of zeroes equal in length to number of surfaces
                my @zero_array;
                foreach (1..6) {push (@zero_array, 0)};
                &replace ($hse_file->{"$ZoneName.geo"}, "#UNUSED_INDEX", 1, 1, "%s\n", "@zero_array");
                &replace ($hse_file->{"$ZoneName.geo"}, "#SURFACE_INDENTATION", 1, 1, "%s\n", "@zero_array");
    
                # last line in GEO file which lists FLOR surfaces (total elements must equal 6) and floor area (m^2) plus another zero
                my @base = (6, 0, 0, 0, 0, 0, $PArea, 0);
                &replace ($hse_file->{"$ZoneName.geo"}, "#BASE", 1, 1, "%s\n", "@base");
                
                # Create the .tmc file
                # --------------------------------------------------------------------
                if ($tmc_flag) {
					&replace ($hse_file->{"$ZoneName.tmc"}, "#SURFACE_COUNT", 1, 1, "%s\n", $#tmc_type + 1);
					my %optic_lib = (0, 0);
					foreach my $element (0..$#tmc_type) {
						my $optic = $tmc_type[$element];
						unless (defined ($optic_lib{$optic})) {
							$optic_lib{$optic} = keys (%optic_lib);
							my $layers = @{$optic_data->{$optic}->{'layers'}};
							&insert ($hse_file->{"$ZoneName.tmc"}, "#END_TMC_DATA", 1, 0, 0, "%s\n", "$layers $optic");
							&insert ($hse_file->{"$ZoneName.tmc"}, "#END_TMC_DATA", 1, 0, 0, "%s\n", "$optic_data->{$optic}->{'optic_con_props'}->{'trans_solar'} $optic_data->{$optic}->{'optic_con_props'}->{'trans_vis'}");
							foreach my $layer (@{$optic_data->{$optic}->{'layers'}}) {
								&insert ($hse_file->{"$ZoneName.tmc"}, "#END_TMC_DATA", 1, 0, 0, "%s\n", $layer->{'absorption'});
							};
							&insert ($hse_file->{"$ZoneName.tmc"}, "#END_TMC_DATA", 1, 0, 0, "%s\n", "0");	# optical control flag
						};
						$tmc_type[$element] = $optic_lib{$optic};	# change from optics name to the appearance number in the tmc file
					};
					&replace ($hse_file->{"$ZoneName.tmc"}, "#TMC_INDEX", 1, 1, "%s\n", "@tmc_type");	# print the key that links each surface to an optic (by number) 
				};
                
                # Create the .htc file
                # --------------------------------------------------------------------
                $surface_index = $surface_index-1;
                my @InHTC=(); # Internal heat transfer coefficients
                my @OutHTC=(); # External heat transfer coefficients
                for (my $i = 1; $i<=$surface_index; $i++) {
                    if ($i < $surface_index) {
                        push(@InHTC, "999.0,");
                        push(@OutHTC, "-1.0000,");
                    } else {
                        push(@InHTC, "999.0");
                        push(@OutHTC, "-1.0000");
                    };
                };
                
                &replace ($hse_file->{"$ZoneName.htc"}, "*HC_CTL", 1, 0, "%s\n", "*HC_CTL for zone $ZoneName");
                &replace ($hse_file->{"$ZoneName.htc"}, "#NUM_CTL_INTV", 1, 0, "%s\n", "  1  # number control intervals");
                &replace ($hse_file->{"$ZoneName.htc"}, "#NUM_SURF", 1, 0, "%s\n", "  $surface_index  # number of surfaces");
                &replace ($hse_file->{"$ZoneName.htc"}, "#SURF_NAMES", 1, 0, "%s\n", "# SURFACES: @sides");
                &insert ($hse_file->{"$ZoneName.htc"}, "#END_PERIODS", 1, 0, 0, "%s\n", "  0.00    24.00 # start and end time of interval");
                &insert ($hse_file->{"$ZoneName.htc"}, "#END_PERIODS", 1, 0, 0, "%s\n", "  1 # fixed coefficients calculation control type");
                &insert ($hse_file->{"$ZoneName.htc"}, "#END_PERIODS", 1, 0, 0, "%s\n", "*Doc,User supplied hc values");
                &insert ($hse_file->{"$ZoneName.htc"}, "#END_PERIODS", 1, 0, 0, "%s\n", "  @InHTC");
                &insert ($hse_file->{"$ZoneName.htc"}, "#END_PERIODS", 1, 0, 0, "%s\n", "  @OutHTC");
                
                # Add d.c. bus and component data for this array in elec
                # --------------------------------------------------------------------
                $NumEnodes++;; # Increase number of electrical nodes
                my $SPMnode = $CurrZone - $Num_zones; # Determine special material node
                # Make d.c. bus
                &replace ($hse_file->{'elec'}, "#NODES", 1, 1, "%s\n", "  $NumEnodes");
                &insert ($hse_file->{'elec'}, "#END_NODES_DATA", 1, 0, 0, "%s\n", "    $NumEnodes  n_PV_$PVName       d.c.          1  calc_PV           240.00    $SPMnode");
                # Assuming there was no hybrid components in the base
                &replace ($hse_file->{'elec'}, "#NUM_HYBRID_COMPONENTS ", 1, 1, "%s\n", "  $SPMnode");
                &insert ($hse_file->{'elec'}, "#END_HYBRID_COMPONENT_INFO", 1, 0, 0, "%s\n", "  $SPMnode  spmaterial  PV_$PVName       d.c.           $NumEnodes    0    0    $SPMnode    0    0");
                &insert ($hse_file->{'elec'}, "#END_HYBRID_COMPONENT_INFO", 1, 0, 0, "%s\n", " The PV-array connected to PV_$PVName for electricity generation");
                &insert ($hse_file->{'elec'}, "#END_HYBRID_COMPONENT_INFO", 1, 0, 0, "%s\n", "  0");
                
                # Create an inverter for this array
                my $InvPnm = &invert_nom($PVZones->{$PVName}->{'NumColl'}*$PVdata->{'P_rated'}); # Nominal power rating for inverter [W]
                
                if ($InvPnm == 9999) { # Array rating lager than available inverters
                    #TODO Error handling
                };
                
                my $OpMode = '1'; # Operation mode: 1 is power input know, 2 is output known
                my $NomPow = sprintf("%5.1f", $Inverter_data->{"_$InvPnm"}->{'Pn'});
                my $IdleC = sprintf("%6.5E", $Inverter_data->{"_$InvPnm"}->{'P0Pn'});
                my $SetV = sprintf("%6.5f", $Inverter_data->{"_$InvPnm"}->{'Us'});
                my $InRes = sprintf("%7.6E", $Inverter_data->{"_$InvPnm"}->{'RiPn'});
                my $AuxPow = sprintf("%5.1f", $Inverter_data->{"_$InvPnm"}->{'AuxPwr'});
                my $InverterDesc = $Inverter_data->{"_$InvPnm"}->{'description'};
                
                $NumPowOnly++;
                &replace ($hse_file->{'elec'}, "#NUM_POWER_ONLY_COMPONENTS", 1, 1, "%s\n", "  $NumPowOnly");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "# No.   i.d.  Comp. name   Phase type  links to nodes ");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "    $NumPowOnly   20  INV_$PVName        d.c.            $NumEnodes    0    0");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", " $InverterDesc n_PV_$PVName");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "# Number of additional data items:");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "    6    0");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "    $OpMode        $NomPow       $IdleC    $SetV       $InRes    $AuxPow");
                &insert ($hse_file->{'elec'}, "#END_POWER_ONLY_COMPONENT_INFO", 1, 0, 0, "%s\n", "    $NumEnodes    1"); # Connect back to the AC bus (should be first node)
                
                # Create the .opr file
                # --------------------------------------------------------------------
                my @OPR_FLAG = ("#END_AIR_WEEKDAY","#END_AIR_SATURDAY","#END_AIR_SUNDAY","#END_CASUAL_WEEKDAY", "#END_CASUAL_SATURDAY","#END_CASUAL_SUNDAY");
                foreach my $opFlag (@OPR_FLAG) {
                    &insert ($hse_file->{"$ZoneName.opr"}, $opFlag, 1, 0, 0, "%s\n", "0");
                };

            }; # End of PV Zone creation Loop
            
            # Update zone names in cfg
            # --------------------------------------------------------------------
            for (my $i=0;$i<=$#{$hse_file->{'cfg'}};$i++) { 
                if (@{$hse_file->{'cfg'}}[$i] =~ m/(#PLANT)/) {
                    my @tokens = split '#', @{$hse_file->{'cfg'}}[$i-1];
                    foreach my $PVName (keys (%{$PVZones})) {
                        $tokens[0] = $tokens[0] . " $PVName" . '_PV';
                    };
                    my $Pback = $tokens[0] . ' # ' . $tokens[1];
                    &replace ($hse_file->{'cfg'}, "#PLANT", 1, -1, "%s\n", $Pback);
                    last;
                };
            };
            
            # Update number of connections for model
            # --------------------------------------------------------------------
            for (my $i=0;$i<=$#{$hse_file->{'cnn'}};$i++) {
                if (@{$hse_file->{'cnn'}}[$i] =~ m/(#CNN_COUNT: number of connections)/) {
                    my $Oldcons = @{$hse_file->{'cnn'}}[$i+1];
                    $NewSurfaces = $NewSurfaces+$Oldcons;
                    &replace ($hse_file->{'cnn'}, "#CNN_COUNT: number of connections", 1, 1, "%s\n", "$NewSurfaces");
                    last;
                };
            };
            
            # Update zone links in control file
            # --------------------------------------------------------------------
            for (my $i = 1; $i <= $#{$hse_file->{'ctl'}}; $i++) {
                if (${$hse_file->{'ctl'}}[$i] =~ /(#ZONE_LINKS)/) {
                    my @newline = split(' ',${$hse_file->{'ctl'}}[$i+1]);
                    my $ctlLoop = $newline[$#newline];
                    for (my $j=0;$j < $PVZoneCount; $j++) {
                        push(@newline, "$ctlLoop");
                    };
                    ${$hse_file->{'ctl'}}[$i+1] = "@newline \n";
                    last;
                };
            };

            # Update number of nodes in afn
            # --------------------------------------------------------------------
            for (my $i=0;$i<=$#{$hse_file->{'afn'}};$i++) {
                if (@{$hse_file->{'afn'}}[$i] =~ m/(# example: 3 2 2 0.75)/) {
                    my @tokens = split ' ', @{$hse_file->{'afn'}}[$i+1];  # Split the afn data
                    $tokens[0] = $tokens[0]+$PVZoneCount;
                    &replace ($hse_file->{'afn'}, "# example: 3 2 2 0.75", 1, 1, "%s\n", "@tokens");
                    last;
                };
            };
            
            # Generate .spm file for the PV arrays for this house
            # --------------------------------------------------------------------
            my $SPMfile = $hse_name . ".spm";
            if ($PVZoneCount > 0) {     #There are PV arrays for this house, make the .spm file
                &replace ($hse_file->{'spm'}, "# configuration file tempelate.cfg", 1, 0, "%s\n", "# configuration file $hse_name.cfg");
                &replace ($hse_file->{'spm'}, "#NUM_SPM_NODE", 1, 1, "%s\n", "   $PVZoneCount  # Number of special material nodes.");
                
                # Format PV input data
                my $PV_Voc = sprintf ("%4.4f",$PVdata->{'Voc'});
                my $PV_Isc = sprintf ("%4.4f",$PVdata->{'Isc'});
                my $PV_Vmpp = sprintf ("%4.4f",$PVdata->{'Vmpp'});
                my $PV_Impp = sprintf ("%4.4f",$PVdata->{'Impp'});
                my $Href = sprintf ("%4.4f",$PVdata->{'ref_ins'});
                my $Tref = sprintf ("%4.4f",$PVdata->{'ref_temp'});
                my $alpha = sprintf ("%4.6f",$PVdata->{'alpha'});
                my $gamma = sprintf ("%4.4f",$PVdata->{'gamma'});
                my $cells = sprintf ("%4.4f",$PVdata->{'cells'});
                my $loadType = sprintf ("%4.4f",$PVdata->{'load_type'});
                my $loadVal = sprintf ("%4.4f",$PVdata->{'load_value'});
                my $shade = sprintf ("%4.4f",$PVdata->{'shading'});
                my $MiscLoss = sprintf ("%4.4f",$PVdata->{'mis_factor'});
                
                # Determine the coefficient of the logarithm. See "Validation of ESP-rs equivalent one-diode PV model with data from NIST" 
                my $dT = (1.38066/1.60218)*0.0001*$PVdata->{'ref_temp'}*$PVdata->{'idealty_factor'}; # Eqn. 8
                my $Beta = ($PVdata->{'cells'}*$dT)/$PVdata->{'Voc'}; # Eqn. 19
                $Beta =  sprintf ("%4.4f",$Beta);

                my $Node = 1;
                foreach my $PVName (keys (%{$PVZones})) { # Add the PV Data for each node
                
                    my $NumModule = sprintf ("%4.4f",$PVZones->{$PVName}->{'NumColl'});
                    
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "# Node No:  $Node");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "WATSUN-PV_$Node # label");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "# Zone Surf Node Type Opq/Trn");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "   $PVZones->{$PVName}->{'ZoneInd'}   $PVZones->{$PVName}->{'SurfInd'}   4   5   0");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "# Number of data items.");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "  16");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "# Data:");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "   $PV_Voc    $PV_Isc   $PV_Vmpp    $PV_Impp   $Href  $Tref  $alpha    $gamma    $Beta   $cells");
                    &insert ($hse_file->{'spm'}, "#END_SPM_DATA", 1, 0, 0, "%s\n", "    1.0000    $NumModule    $loadType    $loadVal    $shade    $MiscLoss");
                    
                    $Node++;
                };
                #print Dumper $hse_file->{'spm'};
                #sleep;
            };

            &replace ($hse_file->{'cfg'}, "#SPM", 1, 1, "%s\n", "*spf  $SPMfile"); # Add path to .spm file
            
            #print Dumper $hse_file;
            #sleep;
            
            # -----------------------------------------------
			# Print out each new esp-r house file for the house record
			# -----------------------------------------------
			FILE_PRINTOUT: {
				foreach my $ext (keys %{$hse_file}) {	# go through each extention inclusive of the zones for this particular record
                    if ($ext =~ m/^(opr|con|htc|geo|tmc)$/) { # Template file, remove it from HASH
                        undef $hse_file->{$ext};
                    } else {
                        my $file = $dir . "/$hse_name.";
                        my $FILE;
                        open ($FILE, '>', $file . $ext) or die ("Can't open datafile: $file$ext");	# open writeable file
                        foreach my $line (@{$hse_file->{$ext}}) {print $FILE "$line";};	# loop through each element of the array (i.e. line of the final file) and print each line out
                    };
				};
                # Update the XML reports
                my $ThisXMLPath = "$dir" . "/input.xml";
                rename $ThisXMLPath, "$ThisXMLPath.orig";
                unlink $ThisXMLPath;
                copy("../Input_upgrade/h3k_DH_PV.xml",$ThisXMLPath) or die "Copy of $ThisXMLPath failed: $!";
                
			};
        };
        
    print "Thread for PV Upgrade of $hse_type $region - Complete\n";
    
    my $return = {'issues' => $issues, 'PV_Upgrade' => $hseRepData};
    
    return ($return);
    
    };  # END EACHHSE
};	# END MAIN

# -----------------------------------------------
# Write out report data
# -----------------------------------------------
# Create a file to print out the house results to
open (my $RFILE, '>', $ResFname) or die ("\n\nERROR: can't open $ResFname\n");

# Print the header to the file
print $RFILE "*header,region,hse_type,HseName,surface,";
foreach my $item (@{$RepHeader}) {	#  Set report values
    print $RFILE "$item,";
};
print $RFILE "\n";

foreach my $hse_type (keys (%{$RepData})) {
	foreach my $region (keys (%{$RepData->{$hse_type}})) {
        foreach my $hseName (keys (%{$RepData->{$hse_type}->{$region}})) {
            foreach my $surf (keys (%{$RepData->{$hse_type}->{$region}->{$hseName}})) {
                print $RFILE "*data,$region,$hse_type,$hseName,$surf,";
                foreach my $item (@{$RepHeader}) {	#  Set report values
                     print $RFILE "$RepData->{$hse_type}->{$region}->{$hseName}->{$surf}->{$item},";
                };
                print $RFILE "\n";
            };
        };
    };
};

close $RFILE;

# -----------------------------------------------
# Subroutines
# -----------------------------------------------
SUBROUTINES: {

	sub copy_template {	# copy the template file for a particular house
		my $zone = shift;
		my $ext = shift;
		my $hse_file = shift;
		my $coordinates = shift;
		
		
		if (defined ($template->{$ext})) {
			$hse_file->{"$zone.$ext"} = [@{$template->{$ext}}];	# create the template file for the zone
		}
		else {&die_msg ('INITIALIZE HOUSE FILES: missing template', $ext, $coordinates);};
		return (1);
	};

    sub clean_up_dir { # subroutine to destroy PV upgrade
        my $set_name = shift;
        my $file = shift;

        # Find all the "old" files for the model and reinstate them
        my @files = glob "$file/*.old";
        for (0..$#files){
            my $To_Del = $files[$_];
            $To_Del =~ s/\.old$//; # Name of new file to be removed
            unlink $To_Del;
            rename $files[$_],$To_Del;
        };
        
        # Find and destroy all PV zone files
        @files = glob "$file/*_PV.*";
        for (0..$#files){
            unlink $files[$_];
        };
        
        # Find and destroy spm file
        @files = glob "$file/*.spm";
        for (0..$#files){
            unlink $files[$_];
        };

        # Remove old summary file
        my $ResFname = "../summary_files/Add_PV$set_name" . '_Houses.csv';
        unlink $ResFname;

    	return (1);
	};

	sub con_surf_PV {	# fill out the construction, surface attributes, and connections for each particular surface
		my $RSI_desired = sprintf ("%.2f", shift); #
		my $zone = shift; # the present zone
		my $surface = shift; # the present surface (e.g. floor, ceiling)
		my $con = shift; # info about the zones and surfaces (e.g. surface indices)
		my $issues = shift; # issue storage
		my $coordinates = shift; # coordinates for issues

		# check to see if the full construction is defined, if it is not, the use the construction database to build it.
		unless (defined ($con->{'layers'})) {
			# Note we are cloning the database so that it is not used itself (messing up subseuqent calls to the database)
			%{$con} = %{dclone($con_data->{$con->{'name'}})};
		};
		
		# otherwise, determine the type (OPAQ or TRAN) from the database
		# This unless protects cloned surfaces from overwritting previous surface data as they both point to the same information
		unless (defined($con->{'type'})) {
			$con->{'type'} = $con_data->{$con->{'name'}}->{'type'};
		};


		# initialize an hash ref to store links to the insulation components
		my $insulation = {};
		
		# intialiaze an RSI value
		$con->{'RSI_orig'} = 0;
		$con->{'RSI_expected'} = $RSI_desired;
		
		# cycle through the layer and determine the total RSI and the insulation layers
		foreach my $layer (@{$con->{'layers'}}) {
			# Store the layers material properties from the database - this value may be modified later
			foreach my $property (qw(conductivity_W_mK density_kg_m3 spec_heat_J_kgK)) {
				# This unless protects cloned surfaces from overwritting previous surface data as they both point to the same information
				unless (defined ($layer->{$property})) {
					$layer->{$property} = $mat_data->{$layer->{'mat'}}->{$property};
				};
			};
			
			# if the layers component type begins with insulation then
			if ($layer->{'component'} =~ /^insulation/) {
				# store the reference to the insulation layer properties
				$insulation->{$layer->{'component'}} = $layer;
			};
		};
		
		# format the calculated value
		$con->{'RSI_orig'} = sprintf ("%.2f", $con->{'RSI_orig'});

		# if the desired RSI is 0 that means do not modify for an RSI value
		# if it is other than zero, modify the insulation to achieve the desired value
		# NOTE: do not adjust reversed construction as denoted by code string -1 (because other codes have letters)
		if ($RSI_desired != 0 && $con->{'code'} ne '-1') {
		
			# create a local RSI so we can modify it with the insulation layers without affecting the original value
			my $RSI = $con->{'RSI_orig'};
			
			
			# cycle through the insulation layers to adjust their thickness to equate the RSI to that desired
			INSUL_CHECK: foreach my $layer (@{&order($insulation)}) {
				# calculate the RSI diff (negative means make insulation higher conductivity)
				my $RSI_diff = sprintf("%.2f", $RSI_desired - $RSI);
				
				# Check that we are not zero
				if ($RSI_diff != 0) {
					# Declare min and max conductivity values (W/mK)
					my $min_cond = 0.05 * $insulation->{$layer}->{'conductivity_W_mK'}; # 5% of existing
					my $max_cond = 250; # ESP-r maximum
				
				
					# calculate the present RSI of the insulation
					my $RSI_insul = $insulation->{$layer}->{'thickness_mm'} / 1000 / $insulation->{$layer}->{'conductivity_W_mK'};
					
					# store the original conductivity for later printout
					$insulation->{$layer}->{'conductivity_W_mK_orig'} = $insulation->{$layer}->{'conductivity_W_mK'};

					# Check to see that the values of insul and diff do not sum to zero (otherwise the else will be a divide by zero)
					if (sprintf("%.2f", $RSI_insul + $RSI_diff) <= 0) {
						$insulation->{$layer}->{'conductivity_W_mK'} = $max_cond;
					} # Set conductivity to zero
					else { # Calculate the new layer conductivity
						$insulation->{$layer}->{'conductivity_W_mK'} = $insulation->{$layer}->{'thickness_mm'} / 1000 / ($RSI_insul + $RSI_diff);
					};
					
					# Check the range of the conductivity - pick a minimum allowable conductivity_W_mK (5% of existing) and max of 250 corresponding to ESP-r
					($insulation->{$layer}->{'conductivity_W_mK'}, $issues) = check_range("%.3f", $insulation->{$layer}->{'conductivity_W_mK'}, $min_cond, $max_cond, 'CONSTRUCTION layer conductivity', $coordinates, $issues);

					# Calculate the new insul RSI
					my $RSI_insul2 = $insulation->{$layer}->{'thickness_mm'} / 1000 / $insulation->{$layer}->{'conductivity_W_mK'};
					# Update the RSI by the change in the insul RSI (- original + new)
					$RSI = $RSI - $RSI_insul + $RSI_insul2;

				};
			};
		};
		
# 		print Dumper $con;
		# Adjustment for framing in the specific heat and density
		# NOTE: do not adjust reversed construction as denoted by code string -1 (because other codes have letters)
		if ($con->{'code'} ne '-1' && defined($con->{'framing'}->{'type'}) && defined($insulation->{'insulation_1'})) {
			# only adjust the values for wood framed, because metal and cwj and truss have so little material in comparison with conventional framing
			if ($con->{'framing'}->{'type'} =~ /wood/) {
				# 'f' is framing
				# 'i' is insulation by itself within the framing
				# 'I' is the insulation considering its replacement of framing. (e.g. the area of 'I' will be larger than 'i')
				
				# Determine the areas
				my $Area_f = $con->{'framing'}->{'thickness_mm'} * $con->{'framing'}->{'width'};
				my $Area_i = $insulation->{'insulation_1'}->{'thickness_mm'} * ($con->{'framing'}->{'spacing'} - $con->{'framing'}->{'width'});
				my $Area_I = $insulation->{'insulation_1'}->{'thickness_mm'} * $con->{'framing'}->{'spacing'};
				
				# Determine the density and specific heat
				my $Rho_f = $mat_data->{'SPF'}->{'density_kg_m3'};
				my $Rho_i = $insulation->{'insulation_1'}->{'density_kg_m3'};
				
				my $C_f = $mat_data->{'SPF'}->{'spec_heat_J_kgK'};
				my $C_i = $insulation->{'insulation_1'}->{'spec_heat_J_kgK'};
				
				# Calculate the area weighted density
				my $Rho_I = ($Rho_f * $Area_f + $Rho_i * $Area_i) / $Area_I;
				# Calculate the area and density weighted Cp
				my $C_I = ($C_f * $Rho_f * $Area_f + $C_i * $Rho_i * $Area_i) / ($Rho_I * $Area_I);
				
				# Replace the insulation values to account for this
				$insulation->{'insulation_1'}->{'density_kg_m3'} = sprintf("%.1f", $Rho_I);
				$insulation->{'insulation_1'}->{'spec_heat_J_kgK'} = sprintf("%.0f", $C_I);
			};
		};
		
	
		$con->{'RSI_final'} = 0;
		# cycle through the layer and determine the total RSI for comparison NOTE: this is a double check
		foreach my $layer (@{$con->{'layers'}}) {
			# RSI = (mm/1000)/k
			$con->{'RSI_final'} = $con->{'RSI_final'} + ($layer->{'thickness_mm'} / 1000) / $layer->{'conductivity_W_mK'};
		};
		
		# format the calculated value
		$con->{'RSI_final'} = sprintf ("%.2f", $con->{'RSI_final'});
		
		# report if the values is not as expected
		if ($RSI_desired != 0 && abs($con->{'RSI_final'} - $RSI_desired) > 0.1) {
			$issues = set_issue("%s", $issues, 'Insulation', 'Cannot alter insulation to equal RSI_desired (RSI RSI_desired zone surface house)', "$con->{'RSI_final'} $RSI_desired $zone $surface", $coordinates);
		};

		return (1);
	};
    
    sub invert_nom {	# Select the required nominal power rating for given array 
		my $Qarray = shift; # Nominal power output of array
        my $Pnom;           # Nominal power rating of inverter

		if ($Qarray <= 200) {
			$Pnom = 200;
		} elsif ($Qarray <= 1100) {
            $Pnom = 1100;
        } elsif ($Qarray <= 1670) {
            $Pnom = 1670;
        } elsif ($Qarray <= 2000) {
            $Pnom = 2000;
        } elsif ($Qarray <= 3000) {
            $Pnom = 3000;
        } elsif ($Qarray <= 4000) {
            $Pnom = 4000;
        } elsif ($Qarray <= 5000) {
            $Pnom = 5000;
        } elsif ($Qarray <= 6000) {
            $Pnom = 6000;
        } elsif ($Qarray <= 7000) {
            $Pnom = 7000;
        } elsif ($Qarray <= 8000) {
            $Pnom = 8000;
        } elsif ($Qarray <= 10000) {
            $Pnom = 10000;
        } elsif ($Qarray <= 30000) {
            $Pnom = 30000;
        } elsif ($Qarray <= 50000) {
            $Pnom = 50000;
        } elsif ($Qarray <= 75000) {
            $Pnom = 75000;
        } elsif ($Qarray <= 100000) {
            $Pnom = 100000;
        } elsif ($Qarray <= 135000) {
            $Pnom = 135000;
        } elsif ($Qarray <= 250000) {
            $Pnom = 250000;
        } else { # Array power bigger than available units
            $Pnom = 9999;
        };
        
        
		return ($Pnom);
	};

};
