#!/usr/bin/perl

# ====================================================================
# Add_PV.pl
# Author: Adam Wills
# Date: Feb 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use CSV;	# CSV-2 (for CSV split and join, this works best)
use Data::Dumper;	# to dump info to the terminal for debugging purposes
use threads;	# threads-1.71 (to multithread the program)
use File::Copy;
use Math::Polygon;
use Math::Trig;

use lib qw(./modules);
use General;
use PV;
use Upgrade;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my @folders;	#declare an array to store the path to each hse which will be simulated
my @houses_desired = '.';
my @coord = ('x','y','z');
my @sides = ('base_frm', 'left_frm', 'top_frm', 'right_frm','PV_module','back_frm'); # surfaces of PV module

# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV == 0 || @ARGV == 2) {die "Three arguments are required: house_types regions set_name\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
}
else { # An inappropriate set_name was provided so die and leave a message
	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
};

# --------------------------------------------------------------------
# Read the PV parameters
# --------------------------------------------------------------------

my $PVkey = '../Input_upgrade/Input_PV.csv';
system ("printf \"Reading $PVkey\"");
# Open and read the crosslisting, note that the file handle below is a variable so that it simply goes out of scope
open (my $PVFILE, '<', $PVkey) or die ("can't open datafile: $PVkey");
my $PVdata;	# create an crosslisting hash reference
while (<$PVFILE>) {
	$_ = rm_EOL_and_trim($_);
	
	if ($_ =~ s/^\*header,//) {	# header row has *header tag, so remove this portion, and the key (first header value) leaving the CSV information
		$PVdata->{'header'} = [CSVsplit($_)];	# split the header into an array
	}
		
	elsif ($_ =~ s/^\*data,//) {	# data lines will begin with the *data tag, so remove this portion, leaving the CSV information
		@_ = CSVsplit($_);	# split the data onto the @_ array
		
		# create a hash slice that uses the header and data array
		# although this is a complex structure it simply creates a hash with an array of keys and array of values
		# @{$hash_ref}{@keys} = @values
		@{$PVdata}{@{$PVdata->{'header'}}} = @_;
	};
};
delete $PVdata->{'header'};
# notify the user we are complete and start a new line
print " - Complete\n";
close($PVFILE);
#print Dumper $PVdata;

# Check data
unless (defined ($PVdata->{'Vmpp'})) {
	die "The voltage at maximum power point is not defined! \n";
}
elsif ($PVdata->{'Vmpp'} <= 0) {
	die "The value of voltage at maximum power point is not correct! \n";
}
unless (defined ($PVdata->{'Isc'})) {
	die "The short-circuit current is not defined! \n";
}
elsif ($PVdata->{'Isc'} <= 0) {
	die "The short-circuit current value is not correct! \n";
}
if ($PVdata->{'Voc/Vmpp'} < 1 ||  $PVdata->{'Voc/Vmpp'} > 2) {
	die "The Voc/Vmpp ratio is out of range!\n";
}
if ($PVdata->{'Isc/Impp'} < 1 ||  $PVdata->{'Voc/Vmpp'} > 2) {
	die "The Isc/Impp ratio is out of range!\n";
}
if ($PVdata->{'efficiency'} < 0 || $PVdata->{'efficiency'} > 100) {
	die "The efficiency shall be between 0 and 100! \n";
}
if ($PVdata->{'mis_factor'} < 0 || $PVdata->{'mis_factor'} > 1) {
	die "The efficiency shall be between 0 and 1! \n";
}
if ($PVdata->{'Area'} < 0 ) {
	die "The area needs to be greater than 0! \n";
}
if ($PVdata->{'Length'} < 0 || $PVdata->{'Width'} < 0 || $PVdata->{'Thick'} < 0) {
	die "PV module dimensions need to be greater than 0! \n";
}

# -----------------------------------------------
# Declare important variables for file generation
# -----------------------------------------------
$zone_extensions = ['cfc', 'con', 'geo', 'opr', 'tmc'];	# extentions that are used for individual zones

# -----------------------------------------------
# Read in the templates
# -----------------------------------------------
my $template;	# declare a hash reference to hold the original templates for use with the generation house files for each record

# Open and read the template files
foreach my $ext (@{$zone_extensions}) {	# do for each filename extention
	my $file = "../templates/template.$ext";
	# note that the file handle below is a variable so that it simply goes out of scope
	open (my $TEMPLATE, '<', $file) or die ("can't open template: $file");	# open the template
	$template->{$ext} = [<$TEMPLATE>];	# Slurp the entire file with one line per array element
}

# --------------------------------------------------------------------
# Begin multi-threading for regions and house types
# --------------------------------------------------------------------
MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
        };
    };     
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        
        push (my @dirs, <../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        # print Dumper @dirs;
        
        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        
        foreach my $dir (@dirs) {
        EACHHSE: {
            my $Roof_type;
            my $Num_zones = 0;
            
            # Determine the house name
            my $hse_name = $dir;
            $hse_name =~ s{.*/}{};
            $hse_name =~ s/_[0-9]+//; 	 # Clean up house name if duplicate	
            print "Record is $hse_name\n";
            # TODO: If a .spm file exists, die
            
            # Find all the geometry files for the model
            my @files = glob "$dir/*.geo";
            for (0..$#files){
                $files[$_] =~ s/\.geo$//; # Remove geo extension
                $files[$_] =~ s/.*\.//; # Remove house prefix and path
            };
            
            # Determine if an attic or roof
            foreach my $zone (@files) {
                $Num_zones++;
                if($zone =~ m/(attic|roof)/i) {$Roof_type = $zone};
            };
            if( length $Roof_type ) {
                # TODO: Error Handling, no roof type
            };

            # If $zone='roof', skip this house as it has a flat roof
            if($Roof_type =~ m/(roof)/i) {
                print "$hse_name has a flat roof, skipping to next house\n";
                # RECORD AREA OF FLAT ROOF
                last EACHHSE;
            };
            
            my $hse_file;	# new hash reference to the ESP-r files for this record
            foreach my $ext (@{$zone_extensions}) {
                $hse_file->{$ext} = [@{$template->{$ext}}];	# create the template file for the zone
			};
            
            
            # --------------------------------------------------------------------
            # Interrogate the geometry file
            # --------------------------------------------------------------------
            my $GeoPath = $dir . "/" . $hse_name . "." . $Roof_type . ".geo"; # Path to roof/attic geo file
            my $OldPath = $GeoPath . ".old";
            
            # Save original geo file
            copy($GeoPath,$OldPath);
            #unlink $GeoPath; # Clear the way for re-writing the geometry file
            
            my $OldGeo;
            open $OldGeo, $OldPath or die "Could not open $OldPath\n";
            
            my @lines = <$OldGeo>; # Pull entire file into an array
            my $counter=0; # initialize counter, used to index lines in file
            
            ORIENT: { # Find model angle of rotation
                my $past=1; # counter to skip over .geo description line
                foreach my $line (@lines) {
                    if ($line !~ m/^(#)/i) { # Not a commented line
                        if ($past < 2) {
                            $past++; 
                        } else {
                            last ORIENT;
                        };    
                    };
                    $counter++;
                };
            }; # END: ORIENT
            
            my @tokens = split ' ', $lines[$counter];
            my $NumVert = $tokens[0]; # Number of vertices
            my $NumSurf = $tokens[1]; # Number of surfaces
            my $AngRot = $tokens[2];  # Angle of rotation
            @tokens = (); # Clear array
            $counter++; # Advance to next line
            
            # Read and store vertex data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $vertex; # HASH to hold vertex info
            my $stop = $NumVert+$counter;
            my $Vert = 1;
            while ($counter < $stop) {
                my @tokens = split ' ', $lines[$counter];
                my $rec = {};
                $vertex->{$Vert} = $rec;
                my $j = 0;
                foreach my $coord (@coord) {
                    $rec->{$coord} = $tokens[$j];
                    $j++;
                };
                $counter++;
                $Vert++;
            };
            

            # Read and store surface geometry data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $surf; # HASH to hold surface info
            my $sNum = 1;
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                my $rec = {};
                $surf->{$sNum} = $rec; # Surface number
                $rec->{'num_vert'}= $tokens[0]; # Number of vertices that defines this surface
                my $nV = $tokens[0];
                $rec->{'name'}= $tokens[($nV+2)]; # Name of surface
                
                # Store vertexes that make up surface
                my $subRec = {};
                $surf->{$sNum}->{'vert_lst'} = $subRec;
                for (my $j=1; $j <= $nV; $j++) {
                    $subRec->{$j} = $tokens[$j]
                };
                $counter++;
                $sNum++;
            };
            
            # Read and store construction data
            my $past = 1;
            while ($lines[$counter] =~ m/^(#)/i || $past < 4) { # Skip over comments
                if ($lines[$counter] !~ m/^(#)/i) {$past++}; # Line is no commented, but don't need this data
                $counter++;
            };
            $sNum = 1; # Surface indexer
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                $surf->{$sNum}->{'con'}= $tokens[4]; # surface construction
                $counter++;
                $sNum++;
            };
            
            close $OldGeo;
            
            # --------------------------------------------------------------------
            # Determine eligible surfaces for PV
            # --------------------------------------------------------------------
            # Only surfaces with construction type 'slop'
            
            # Initialize HASH to hold PV geometry and data
            my $PVSurfaces;
            foreach my $index (keys (%{$surf})) {
                if ($surf->{$index}->{'name'} !~ m/^(floor|ceiling)/i && $surf->{$index}->{'con'} =~ m/(slop)$/i) { # surface is not a floor or ceiling, and is sloped
                    
                    my @P = (); # Array to hold coordinates of vertices 
                    # Determine Cartesian coordinates of all points that define the surface
                    for (my $i = 1; $i <= $surf->{$index}->{'num_vert'}; $i++) {
                        my $VertNumber = $surf->{$index}->{'vert_lst'}->{$i};
                        foreach my $point (@coord) {
                            push(@P, $vertex->{$VertNumber}->{$point});
                        };
                    };

                    # Determine surface orientation # CHECK SURFACE 0 < SLOPE < 90 AND 90 < AZIMUTH < 270
                    # Isolate first 3 points
                    my @p1=();
                    my @p2=();
                    my @p3=();
                    my $j=0;
                    while ($j < 3) {
                        push(@p1,$P[$j]);
                        $j++;
                    };
                    while ($j < 6) {
                        push(@p2,$P[$j]);
                        $j++;
                    };
                    while ($j < 9) {
                        push(@p3,$P[$j]);
                        $j++;
                    };
                    
                    my ($Slope,$Azimuth, $n_ref) = &surf_slope_azimuth($AngRot,\@p1,\@p2,\@p3);
                    my @n = @$n_ref; # Normal vector of surface, magnitude 1, unrotated
                    my ($poly, $shape,$length_r) = &poly_obj(\@P,\@n,$surf->{$index}->{'num_vert'});
                    my @lengths = @$length_r;
                    my $area = $poly->area;
                    my $NumColl=0; # Number of collectors that can fit onto the surface
                    
                    # Determine if the surface is eligible for PV
                    if ($area > $PVdata->{'Area'} && $Azimuth >= 90 && $Azimuth <= 270 && $Slope < 90) {
                        if ($shape =~ m/^(rect)/i) { # surface geometry is rectangular
                            # Call bin packing algorithm
                            $NumColl=&rect_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                            #print "Number of collectors is $NumColl\n";
                            #sleep;
                        } elsif ($shape =~ m/^(trap)/i) { # surface geometry is rectangular
                            $NumColl=&trap_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } elsif ($shape =~ m/^(tri)/i) { # surface geometry is triangular
                            $NumColl=&tri_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } else {
                            # TODO: ERROR HANDLING
                        };
                    };
                    
                    if ($NumColl > 0) { # Collectors may be placed on this surface
                        $PVSurfaces->{$surf->{$index}->{'name'}}->{'Area'} = $NumColl*($PVdata->{'Area'});
                        $PVSurfaces->{$surf->{$index}->{'name'}}->{'Slope'} = $Slope;
                        $PVSurfaces->{$surf->{$index}->{'name'}}->{'Azimuth'} = $Azimuth;
                    };
                };
            };
            
            # --------------------------------------------------------------------
            # Begin making PV zones
            # --------------------------------------------------------------------
            my $ZoneCount=1;
            my $PV_orientation = {qw(front SLOP back SLOP right VERT left VERT)};
            foreach my $PVName (keys (%{$PVSurfaces})) {
                my $ZoneName = "$hse_name" . '.' . '$PVName' . '_PV';
                my $PArea = $PVSurfaces->{$PVName}->{'Area'};
                my $PSlope = $PVSurfaces->{$PVName}->{'Slope'};
                my $PAzim = $PVSurfaces->{$PVName}->{'Azimuth'};
                $Pazim = sprintf("%d", $PAzim);
                
                &replace ($hse_file->{"$ZoneName.geo"}, "#ZONE_NAME", 1, 1, "%s\n", "GEN $ZoneName This file describes the ficticious $ZoneName");	# set the name at the top of each zone geo file
                &replace ($hse_file->{"$ZoneName.geo"}, "#VER_SUR_ROT", 1, 1, "%u %u %u\n", 8, 6, $Pazim); # Set number of zone vertices and surfaces, and orientation
                
                # SET THE ORIGIN AND MAJOR VERTICES OF THE ZONE (note the formatting), Set PV 20 m north of origin
                
                # Store base vertices
                my $x1 = sqrt($PArea)/2;	
				my $x2 = -1*$x1;
				my $y1 = sprintf("%6.2f", 20);
				my $y2 = 20-cos(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
				my $z1 = sin(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
				my $z2 = sprintf("%6.3f", 0);
                # Formatting
                $x1 = sprintf("%6.2f", $x1);
                $z1 = sprintf("%6.3f", $z1); 
                $x2 = sprintf("%6.2f", $x2);

                push (@{$PVSurfaces->{$PVName}->{'vertices'}->{'base'}},	# base vertices in CCW (looking down)
				"$x1 $y1 $z1", "$x2 $y1 $z1", "$x2 $y2 $z2", "$x1 $y2 $z2");
                            
                # Store top vertices
				my $y3 = 20-sqrt($PArea)*cos(deg2rad($PSlope));
                my $y4 = $y3-cos(deg2rad(90-$PSlope))*$PVdata->{'Thick'};
                my $z3 = (sin(deg2rad($PSlope))*sqrt($PArea))+(sin(deg2rad(90-$PSlope))*$PVdata->{'Thick'});
                my $z4 = sin(deg2rad($PSlope))*sqrt($PArea);
                # Formatting
                $y3 = sprintf("%6.2f", $y3); 
                $z3 = sprintf("%6.3f", $z3);
                $z4 = sprintf("%6.3f", $z3);
                
                push (@{$PVSurfaces->{$PVName}->{'vertices'}->{'top'}},	# top vertices in CCW (looking down)
				"$x1 $y3 $z3", "$x2 $y3 $z3", "$x2 $y4 $z4", "$x1 $y4 $z4");
                
                # Begin .geo file creation
                # --------------------------------------------------------------------
                my $vertex_count = 1;
                foreach my $wSurf ('base', 'top') {
					# loop over the vertices in the array
					foreach my $verte (0..$#{$PVSurfaces->{$PVName}->{'vertices'}->{$wSurf}}) {
						# increment the counter
						$vertex_count++;
						# insert the vertex with some information
						&insert ($hse_file->{"$ZoneName.geo"}, "#END_VERTICES", 1, 0, 0, "%s # %s%u; %s\n", $record_indc->{$zone}->{'vertices'}->{$wSurf}->[$verte], "$wSurf v", $verte + 1, "total v$vertex_count");
					};
				};
                
                # @sides = ('base_frm', 'left_frm', 'top_frm', 'right_frm','PV_module','back_frm');
                
                # Begin defining PV module surface attributes
                my $surface_index = 1;
                foreach my $wSurf (@sides) {
                    if ($wSurf =~ /frm/i && $wSurf !~ /base/i) { # Side frame of the PV
                        $PVSurfaces->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'OPAQ', 'VERT', 'PV_frame', 'EXTERIOR'];
                    } elsif ($wSurf =~ /base/i) { # Back of the PV
                        $PVSurfaces->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'OPAQ', 'SLOP', 'PV_frame', 'EXTERIOR'];
                    } else { # It's the PV surface
                        $PVSurfaces->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'} = [$surface_index, $wSurf, 'TRAN', 'SLOP', 'PV_top', 'EXTERIOR'];
                    };
                    &insert ($hse_file->{"$ZoneName.geo"}, '#END_SURFACE_ATTRIBUTES', 1, 0, 0, "%3s, %-13s %-5s %-5s %-12s %-15s\n", @{$PVSurfaces->{$PVName}->{'surfaces'}->{$wSurf}->{'surf_attributes'}});
                    $surface_index++;
                };
                
                # Define PV module surface vertices
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'base_frm'}->{'vertices'}},1,4,3,2);
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'left_frm'}->{'vertices'}},2,3,7,6);
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'top_frm'}->{'vertices'}},5,6,7,8);
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'right_frm'}->{'vertices'}},1,5,8,4);
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'PV_module'}->{'vertices'}},1,2,6,5);
                push(@{$PVSurfaces->{$PVName}->{'surfaces'}->{'back_frm'}->{'vertices'}},4,8,7,3);
                
                # Add surface vertex info to the .geo file
                foreach my $wSurf (@sides) {
                    &insert ($hse_file->{"$ZoneName.geo"}, '#END_SURFACES', 1, 0, 0, "%u %s # %s\n", '4', "@{$PVSurfaces->{$PVName}->{'surfaces'}->{$wSurf}->{'vertices'}}", $wSurf);
                };
                
                # fill out the unused and indentation indexes with array of zeroes equal in length to number of surfaces
                my @zero_array;
                foreach (1..6) {push (@zero_array, 0)};
                &replace ($hse_file->{"$ZoneName.geo"}, "#UNUSED_INDEX", 1, 1, "%s\n", "@zero_array");
                &replace ($hse_file->{"$ZoneName.geo"}, "#SURFACE_INDENTATION", 1, 1, "%s\n", "@zero_array");
    
                # last line in GEO file which lists FLOR surfaces (total elements must equal 6) and floor area (m^2) plus another zero
                my @base = (6, 0, 0, 0, 0, 0, $PArea, 0);
                &replace ($hse_file->{"$ZoneName.geo"}, "#BASE", 1, 1, "%s\n", "@base");
                
                # Begin .spm file creation
                # --------------------------------------------------------------------
                my $num_nodes = 1;
				my $PV_zone =  $Num_zones+$ZoneCount; # the PV zone number 
				my $PV_surf = 5; # the surface number which PV is installed
				
				my $PV_Voc = sprintf ("%4.4f",$PVdata->{'Vmpp'} * $PVdata->{'Voc/Vmpp'}); # open circuit voltage (V)
				my $PV_Impp = sprintf ("%4.4f",$PVdata->{'Isc'} /  $PVdata->{'Isc/Impp'}); # Current at maximum power point (I)
				my $Href = sprintf ("%4.4f",1000); # reference insolation (W/m2)
				my $alpha = sprintf ("%4.6f",$PVdata->'alpha*1000'} / 1000); # temperature coefficient of short circuit current (1/K)
				my $beta = sprintf ("%4.4f",$PVdata->{'beta*1000'} / 1000); # coefficient of logarithm of irradiance for open corcuit voltage (-)
				my $gamma = sprintf ("%4.4f",$PVdata->{'gamma*1000'} / -1000); # temperature coefficient of open-circuit voltage (1/K)
				my $PV_Isc = sprintf ("%4.4f",$PVdata->{'Isc'});
				my $PV_Vmpp = sprintf ("%4.4f",$PVdata->{'Vmpp'});
				
				my $N = $Href * $input->{$up_name}->{'efficiency'}/100 * $PV_area / $input->{$up_name}->{'power_individual'}; # number of modules on the surface can be calculated when area is defined as the largest integer number less than (Href * efficiency * area / power_individual)
				my $floor_N = sprintf ("%4.4f",floor ($N));
				my $PV_factor =  sprintf ("%4.4f",$input->{$up_name}->{'mis_factor'});
				
				&insert ($hse_file->{"spm"}, "#END_SPM_DATA", 1, 0, 0, "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n", "# Node No: $num_nodes", "WATSUN-PV_multic # label","# Zone Surf Node Type Opq/Trn", "$PV_zone $PV_surf 4 5 0", "# No. of data items.", "16", "# Data:", "$PV_Voc $PV_Isc $PV_Vmpp $PV_Impp $Href 298.0000 $alpha $gamma $beta 36.0000 1.0000 $floor_N 0.0000 0.0000 0.0000 $PV_factor");
                
                $ZoneCount++;
            };
            
            
       

            
            # my $NewGeo;
            # open $NewGeo, '>', $GeoPath or die "Could not generate $GeoPath\n";
            # close $NewGeo;
            
        
        };  # end of house loop
    };  # end of EACHHSE
    };	# end of main code
};