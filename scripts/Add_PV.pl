#!/usr/bin/perl

# ====================================================================
# Add_PV.pl
# Author: Adam Wills
# Date: Feb 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use Data::Dumper;	# to dump info to the terminal for debugging purposes
use threads;	# threads-1.71 (to multithread the program)
use File::Copy;

use lib qw(./modules);
use General;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my @folders;	#declare an array to store the path to each hse which will be simulated
my @houses_desired = '.';
my @coord = ('x','y','z');

# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV == 0 || @ARGV == 2) {die "Three arguments are required: house_types regions set_name\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
}
else { # An inappropriate set_name was provided so die and leave a message
	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
};

MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
        };
    };     
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        
        push (my @dirs, <../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        # print Dumper @dirs;
        
        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        foreach my $dir (@dirs) {
        
            my $Roof_type;
            
            # Determine the house name
            my $hse_name = $dir;
            $hse_name =~ s{.*/}{};
            $hse_name =~ s/_[0-9]+//; 	 # Clean up house name if duplicate	
            
            print "House Name is $hse_name\n";
        
            # Find all the geometry files for the model
            my @files = glob "$dir/*.geo";
            for (0..$#files){
                $files[$_] =~ s/\.geo$//; # Remove geo extension
                $files[$_] =~ s/.*\.//; # Remove house prefix and path
            };
            
            # Determine if an attic or roof
            foreach my $zone (@files) {
                if($zone =~ m/(attic|roof)/i) {$Roof_type = $zone};
            };
            if( length $Roof_type ) {
                # TODO: Error Handling, no roof type
            };
            
            # --------------------------------------------------------------------
            # Interrogate the geometry file
            # --------------------------------------------------------------------
            my $GeoPath = $dir . "/" . $hse_name . "." . $Roof_type . ".geo"; # Path to roof/attic geo file
            my $OldPath = $GeoPath . ".old";
            
            # Save original geo file
            copy($GeoPath,$OldPath);
            #unlink $GeoPath; # Clear the way for re-writing the geometry file
            
            my $OldGeo;
            open $OldGeo, $OldPath or die "Could not open $OldPath\n";
            
            my @lines = <$OldGeo>; # Pull entire file into an array
            my $counter=0; # initialize counter, used to index lines in file
            
            ORIENT: { # Find model angle of rotation
                my $past=1; # counter to skip over .geo description line
                foreach my $line (@lines) {
                    if ($line !~ m/^(#)/i) { # Not a commented line
                        if ($past < 2) {
                            $past++; 
                        } else {
                            last ORIENT;
                        };    
                    };
                    $counter++;
                };
            }; # END: ORIENT
            
            my @tokens = split ' ', $lines[$counter];
            my $NumVert = $tokens[0]; # Number of vertices
            my $NumSurf = $tokens[1]; # Number of surfaces
            my $AngRot = $tokens[2];  # Angle of rotation
            @tokens = (); # Clear array
            $counter++; # Advance to next line
            
            # Read and store vertex data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $vertex; # HASH to hold vertex info
            my $stop = $NumVert+$counter;
            my $Vert = 1;
            while ($counter < $stop) {
                my @tokens = split ' ', $lines[$counter];
                my $rec = {};
                $vertex->{$Vert} = $rec;
                my $j = 0;
                foreach my $coord (@coord) {
                    $rec->{$coord} = $tokens[$j];
                    $j++;
                };
                $counter++;
                $Vert++;
            };
            

            # Read and store surface geometry data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $surf; # HASH to hold surface info
            my $sNum = 1;
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                my $rec = {};
                $surf->{$sNum} = $rec; # Surface number
                $rec->{'num_vert'}= $tokens[0]; # Number of vertices that defines this surface
                my $nV = $tokens[0];
                $rec->{'name'}= $tokens[($nV+2)]; # Name of surface
                
                # Store vertexes that make up surface
                my $subRec = {};
                $surf->{$sNum}->{'vert_lst'} = $subRec;
                for (my $j=1; $j <= $nV; $j++) {
                    $subRec->{$j} = $tokens[$j]
                };
                $counter++;
                $sNum++;
            };
            
            # Read and store construction data
            my $past = 1;
            while ($lines[$counter] =~ m/^(#)/i || $past < 4) { # Skip over comments
                if ($lines[$counter] !~ m/^(#)/i) {$past++}; # Line is no commented, but don't need this data
                $counter++;
            };
            $sNum = 1; # Surface indexer
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                $surf->{$sNum}->{'con'}= $tokens[4]; # surface construction
                $counter++;
                $sNum++;
            };
            
            
            close $OldGeo;
            
            # --------------------------------------------------------------------
            # Determine eligible surfaces for PV
            # --------------------------------------------------------------------
            # If Roof_type is 'roof', the ceiling is flat and only the 'ceiling' surface is
            # may be considered for PV mounting.
            
            # If the Roof_type is 'attic', only surfaces with construction type 'slop', and the
            # ceiling surface may be considered for PV mounting
       

            
            # my $NewGeo;
            # open $NewGeo, '>', $GeoPath or die "Could not generate $GeoPath\n";
            # close $NewGeo;
            
        
        };  # end of house loop
	};	# end of main code
};