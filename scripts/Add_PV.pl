#!/usr/bin/perl

# ====================================================================
# Add_PV.pl
# Author: Adam Wills
# Date: Feb 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use CSV;	# CSV-2 (for CSV split and join, this works best)
use Data::Dumper;	# to dump info to the terminal for debugging purposes
use threads;	# threads-1.71 (to multithread the program)
use File::Copy;
use Math::Polygon;

use lib qw(./modules);
use General;
use PV;
use Upgrade;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my @folders;	#declare an array to store the path to each hse which will be simulated
my @houses_desired = '.';
my @coord = ('x','y','z');

# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV == 0 || @ARGV == 2) {die "Three arguments are required: house_types regions set_name\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
}
else { # An inappropriate set_name was provided so die and leave a message
	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
};

# --------------------------------------------------------------------
# Read the PV parameters
# --------------------------------------------------------------------

my $PVkey = '../Input_upgrade/Input_PV.csv';
system ("printf \"Reading $PVkey\"");
# Open and read the crosslisting, note that the file handle below is a variable so that it simply goes out of scope
open (my $PVFILE, '<', $PVkey) or die ("can't open datafile: $PVkey");
my $PVdata;	# create an crosslisting hash reference
while (<$PVFILE>) {
	$_ = rm_EOL_and_trim($_);
	
	if ($_ =~ s/^\*header,//) {	# header row has *header tag, so remove this portion, and the key (first header value) leaving the CSV information
		$PVdata->{'header'} = [CSVsplit($_)];	# split the header into an array
	}
		
	elsif ($_ =~ s/^\*data,//) {	# data lines will begin with the *data tag, so remove this portion, leaving the CSV information
		@_ = CSVsplit($_);	# split the data onto the @_ array
		
		# create a hash slice that uses the header and data array
		# although this is a complex structure it simply creates a hash with an array of keys and array of values
		# @{$hash_ref}{@keys} = @values
		@{$PVdata}{@{$PVdata->{'header'}}} = @_;
	};
};
delete $PVdata->{'header'};
# notify the user we are complete and start a new line
print " - Complete\n";
close($PVFILE);
# Compute the area
$PVdata->{'Area'} = ($PVdata->{'Length'})*($PVdata->{'Width'});
#print Dumper $PVdata;

# Check data
unless (defined ($PVdata->{'Vmpp'})) {
	die "The voltage at maximum power point is not defined! \n";
}
elsif ($PVdata->{'Vmpp'} <= 0) {
	die "The value of voltage at maximum power point is not correct! \n";
}
unless (defined ($PVdata->{'Isc'})) {
	die "The short-circuit current is not defined! \n";
}
elsif ($PVdata->{'Isc'} <= 0) {
	die "The short-circuit current value is not correct! \n";
}
if ($PVdata->{'Voc/Vmpp'} < 1 ||  $PVdata->{'Voc/Vmpp'} > 2) {
	die "The Voc/Vmpp ratio is out of range!\n";
}
if ($PVdata->{'Isc/Impp'} < 1 ||  $PVdata->{'Voc/Vmpp'} > 2) {
	die "The Isc/Impp ratio is out of range!\n";
}
if ($PVdata->{'efficiency'} < 0 || $PVdata->{'efficiency'} > 100) {
	die "The efficiency shall be between 0 and 100! \n";
}
if ($PVdata->{'mis_factor'} < 0 || $PVdata->{'mis_factor'} > 1) {
	die "The efficiency shall be between 0 and 1! \n";
}

# --------------------------------------------------------------------
# Begin multi-threading for regions and house types
# --------------------------------------------------------------------
MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
        };
    };     
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        
        push (my @dirs, <../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        # print Dumper @dirs;
        
        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        
        foreach my $dir (@dirs) {
        EACHHSE: {
            my $Roof_type;
            
            # Determine the house name
            my $hse_name = $dir;
            $hse_name =~ s{.*/}{};
            $hse_name =~ s/_[0-9]+//; 	 # Clean up house name if duplicate	
            print "Record is $hse_name\n";
            # TODO: If a .spm file exists, die
            
            # Find all the geometry files for the model
            my @files = glob "$dir/*.geo";
            for (0..$#files){
                $files[$_] =~ s/\.geo$//; # Remove geo extension
                $files[$_] =~ s/.*\.//; # Remove house prefix and path
            };
            
            # Determine if an attic or roof
            foreach my $zone (@files) {
                if($zone =~ m/(attic|roof)/i) {$Roof_type = $zone};
            };
            if( length $Roof_type ) {
                # TODO: Error Handling, no roof type
            };

            # If $zone='roof', skip this house as it has a flat roof
            if($Roof_type =~ m/(roof)/i) {
                print "$hse_name has a flat roof, skipping to next house\n";
                # RECORD AREA OF FLAT ROOF
                last EACHHSE;
            };
            
            
            
            # --------------------------------------------------------------------
            # Interrogate the geometry file
            # --------------------------------------------------------------------
            my $GeoPath = $dir . "/" . $hse_name . "." . $Roof_type . ".geo"; # Path to roof/attic geo file
            my $OldPath = $GeoPath . ".old";
            
            # Save original geo file
            copy($GeoPath,$OldPath);
            #unlink $GeoPath; # Clear the way for re-writing the geometry file
            
            my $OldGeo;
            open $OldGeo, $OldPath or die "Could not open $OldPath\n";
            
            my @lines = <$OldGeo>; # Pull entire file into an array
            my $counter=0; # initialize counter, used to index lines in file
            
            ORIENT: { # Find model angle of rotation
                my $past=1; # counter to skip over .geo description line
                foreach my $line (@lines) {
                    if ($line !~ m/^(#)/i) { # Not a commented line
                        if ($past < 2) {
                            $past++; 
                        } else {
                            last ORIENT;
                        };    
                    };
                    $counter++;
                };
            }; # END: ORIENT
            
            my @tokens = split ' ', $lines[$counter];
            my $NumVert = $tokens[0]; # Number of vertices
            my $NumSurf = $tokens[1]; # Number of surfaces
            my $AngRot = $tokens[2];  # Angle of rotation
            @tokens = (); # Clear array
            $counter++; # Advance to next line
            
            # Read and store vertex data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $vertex; # HASH to hold vertex info
            my $stop = $NumVert+$counter;
            my $Vert = 1;
            while ($counter < $stop) {
                my @tokens = split ' ', $lines[$counter];
                my $rec = {};
                $vertex->{$Vert} = $rec;
                my $j = 0;
                foreach my $coord (@coord) {
                    $rec->{$coord} = $tokens[$j];
                    $j++;
                };
                $counter++;
                $Vert++;
            };
            

            # Read and store surface geometry data
            while ($lines[$counter] =~ m/^(#)/i) { # Skip over comments
                $counter++;
            };
            my $surf; # HASH to hold surface info
            my $sNum = 1;
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                my $rec = {};
                $surf->{$sNum} = $rec; # Surface number
                $rec->{'num_vert'}= $tokens[0]; # Number of vertices that defines this surface
                my $nV = $tokens[0];
                $rec->{'name'}= $tokens[($nV+2)]; # Name of surface
                
                # Store vertexes that make up surface
                my $subRec = {};
                $surf->{$sNum}->{'vert_lst'} = $subRec;
                for (my $j=1; $j <= $nV; $j++) {
                    $subRec->{$j} = $tokens[$j]
                };
                $counter++;
                $sNum++;
            };
            
            # Read and store construction data
            my $past = 1;
            while ($lines[$counter] =~ m/^(#)/i || $past < 4) { # Skip over comments
                if ($lines[$counter] !~ m/^(#)/i) {$past++}; # Line is no commented, but don't need this data
                $counter++;
            };
            $sNum = 1; # Surface indexer
            $stop = $counter+$NumSurf;
            while ($counter < $stop) { # Read all the surface info
                my @tokens = split ' ', $lines[$counter];  # Split vertex list for surface
                $surf->{$sNum}->{'con'}= $tokens[4]; # surface construction
                $counter++;
                $sNum++;
            };
            
            close $OldGeo;
            
            # --------------------------------------------------------------------
            # Determine eligible surfaces for PV
            # --------------------------------------------------------------------
            # Only surfaces with construction type 'slop'
            foreach my $index (keys (%{$surf})) {
                if ($surf->{$index}->{'name'} !~ m/^(floor|ceiling)/i && $surf->{$index}->{'con'} =~ m/(slop)$/i) { # surface is not a floor or ceiling, and is sloped
                    
                    my @P = (); # Array to hold coordinates of vertices 
                    # Determine Cartesian coordinates of all points that define the surface
                    for (my $i = 1; $i <= $surf->{$index}->{'num_vert'}; $i++) {
                        my $VertNumber = $surf->{$index}->{'vert_lst'}->{$i};
                        foreach my $point (@coord) {
                            push(@P, $vertex->{$VertNumber}->{$point});
                        };
                    };

                    # Determine surface orientation # CHECK SURFACE 0 < SLOPE < 90 AND 90 < AZIMUTH < 270
                    # Isolate first 3 points
                    my @p1=();
                    my @p2=();
                    my @p3=();
                    my $j=0;
                    while ($j < 3) {
                        push(@p1,$P[$j]);
                        $j++;
                    };
                    while ($j < 6) {
                        push(@p2,$P[$j]);
                        $j++;
                    };
                    while ($j < 9) {
                        push(@p3,$P[$j]);
                        $j++;
                    };
                    
                    my ($Slope,$Azimuth, $n_ref) = &surf_slope_azimuth($AngRot,\@p1,\@p2,\@p3);
                    my @n = @$n_ref; # Normal vector of surface, magnitude 1, unrotated
                    my ($poly, $shape,$length_r) = &poly_obj(\@P,\@n,$surf->{$index}->{'num_vert'});
                    my @lengths = @$length_r;
                    my $area = $poly->area;
                    my $NumColl=0; # Number of collectors that can fit onto the surface
                    
                    # Determine if the surface is eligible for PV
                    if ($area > $PVdata->{'Area'} && $Azimuth >= 90 && $Azimuth <= 270 && $Slope < 90) {
                        if ($shape =~ m/^(rect)/i) { # surface geometry is rectangular
                            # Call bin packing algorithm
                            $NumColl=&rect_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                            #print "Number of collectors is $NumColl\n";
                            #sleep;
                        } elsif ($shape =~ m/^(trap)/i) { # surface geometry is rectangular
                            $NumColl=&trap_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } elsif ($shape =~ m/^(tri)/i) { # surface geometry is triangular
                            $NumColl=&tri_finite_first_fit(\@lengths,$PVdata->{'Length'},$PVdata->{'Width'});
                        } else {
                            # TODO: ERROR HANDLING
                        };
                    };
                    
                    if ($NumColl > 0) { # Collectors may be placed on this surface
                        my $Cover = ($NumColl*($PVdata->{'Area'}))/$area; # Fraction of surface covered in PV
                    };
                };
            };
            
       

            
            # my $NewGeo;
            # open $NewGeo, '>', $GeoPath or die "Could not generate $GeoPath\n";
            # close $NewGeo;
            
        
        };  # end of house loop
    };  # end of EACHHSE
    };	# end of main code
};