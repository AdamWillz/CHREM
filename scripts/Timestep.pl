#!/usr/bin/perl

# ====================================================================
# Timestep.pl
# Author: Adam Wills
# Date: Feb 2015
# Copyright: Carleton University

# INPUT USE:
# filename.pl [house type numbers seperated by "/"] [region numbers seperated by "/"; 0 means all] [set_name]

# DESCRIPTION:
# This script adds roof mounted PV modules to an existing set of houses generated by the CHREM



# The script reads a set of input files:
# 1) CSDDRD type and region database (csv)
# 2) esp-r file templates (template.xxx)
# 3) weather station cross reference list

# The script copies the template files for each house of the CSDDRD and replaces
# and inserts within the templates based on the values of the CSDDRD house. Each 
# template file is explicitly dealt with in the main code (actually a sub) and 
# utilizes insert and replace subroutines to administer the specific house 
# information.

# The script is easily extendable to addtional CSDDRD files and template files.
# Care must be taken that the appropriate lines of the template file are defined 
# and that any required changes in other template files are completed.

# ===================================================================

# --------------------------------------------------------------------
# Declare modules which are used
# --------------------------------------------------------------------

use warnings;
use strict;

use CSV;	# CSV-2 (for CSV split and join, this works best)
use Data::Dumper;	# to dump info to the terminal for debugging purposes
use threads;	# threads-1.71 (to multithread the program)
use File::Copy;
use Math::Polygon;
use Math::Trig;
use Storable  qw(dclone);
use POSIX qw(ceil floor);

use lib qw(./modules);
use General;
use Cross_reference;
use PV;
use Upgrade;
use Database;

# --------------------------------------------------------------------
# Declare the global variables
# --------------------------------------------------------------------

my $hse_types;	# declare an hash array to store the house types to be modeled (e.g. 1 -> 1-SD)
my $regions;	# declare an hash array to store the regions to be modeled (e.g. 1 -> 1-AT)
my $set_name;   # Read in city name from command line
my @folders;	#declare an array to store the path to each hse which will be simulated
my @houses_desired = '.';

# Determine possible set names by scanning the summary_files folder
my $possible_set_names = {map {$_, 1} grep(s/.+Hse_Gen_(.+)_Issues.txt/$1/, <../summary_files/*>)}; # Map to hash keys so there are no repeats
my @possible_set_names_print = @{&order($possible_set_names)}; # Order the names so we can print them out if an inappropriate value was supplied

# --------------------------------------------------------------------
# Read the command line input arguments
# --------------------------------------------------------------------

if (@ARGV == 0 || @ARGV == 3) {die "Four arguments are required: house_types regions set_name run_mode\n";};	# check for proper argument count

# Pass the input arguments of desired house types and regions to setup the $hse_types and $regions hash references
($hse_types, $regions, $set_name) = &hse_types_and_regions_and_set_name(shift (@ARGV), shift (@ARGV), shift (@ARGV));
# Verify the provided set_name
if (defined($possible_set_names->{$set_name})) { # Check to see if it is defined in the list
	$set_name =  '_' . $set_name; # Add and underscore to the start to support subsequent code
}
else { # An inappropriate set_name was provided so die and leave a message
	die "Set_name \"$set_name\" was not found\nPossible set_names are: @possible_set_names_print\n";
};

my $run_mode = shift (@ARGV);
if ($run_mode !~ /[0-1]/) {die "Run mode can be (0 = change timestep to reports), (1= revert) \n";}

if ($run_mode == 1) { # Scan set and undo upgrade
    print "Are you sure you want to run clean-up? \n";
    my $resp = <STDIN>;
    if ($resp !~ /Y|YES/i) {die;}
    foreach my $hse_type (values (%{$hse_types})) {
        foreach my $region (values (%{$regions})) {
            foreach my $file (<../$hse_type$set_name/$region/*>) {
                &clean_up_dir($set_name,$file);
            };
        };
    };
    die "Done clean-up, exiting\n";
};

# --------------------------------------------------------------------
# Begin multi-threading for regions and house types
# --------------------------------------------------------------------
MULTI_THREAD: {
	print "Multi-threading for each House Type and Region : please be patient\n";
	
	my $thread;	# Declare threads for each type and region
	my $thread_return;	# Declare a return array for collation of returning thread data
	
	foreach my $hse_type (values (%{$hse_types})) {	# Multithread for each house type
		foreach my $region (values (%{$regions})) {	# Multithread for each region
			# Add the particular hse_type and region to the pass hash ref
			my $pass = {'hse_type' => $hse_type, 'region' => $region, 'setname' => $set_name};
			$thread->{$hse_type}->{$region} = threads->new(\&main, $pass);	# Spawn the threads and send to main subroutine
		};
	};
    
    foreach my $hse_type (&array_order(values %{$hse_types})) {	# return for each house type
		foreach my $region (&array_order(values %{$regions})) {	# return for each region type
			$thread_return->{$hse_type}->{$region} = $thread->{$hse_type}->{$region}->join();	# Return the threads together for info collation
          
        };
    };
};


# --------------------------------------------------------------------
# Main code that each thread evaluates
# --------------------------------------------------------------------

MAIN: {
	sub main () {
		my $pass = shift;	# the hash reference that contains all of the information

		my $hse_type = $pass->{'hse_type'};	# house type number for the thread
		my $region = $pass->{'region'};	# region number for the thread
        my $set_name = $pass->{'setname'};	# region number for the thread
        
        my $hseRepData; # Hold the PV report data
        
        push (my @dirs, <../$hse_type$set_name/$region/*>);	#read all hse directories and store them in the array
        # print Dumper @dirs;
        
        # --------------------------------------------------------------------
        # Begin processing each house model
        # --------------------------------------------------------------------
        
        foreach my $dir (@dirs) {
            my $hse_name = $dir;

            my $hse_file;	# new hash reference to the ESP-r files for this record
        
            # Determine the house name
            $hse_name =~ s{.*/}{};

            # --------------------------------------------------------------------
            # Load and begin manipulating model files
            # --------------------------------------------------------------------
            
            # Load in building files to be updated
            # foreach my $ext (qw(cfg)) {
            #    my $FILEpath = $dir . "/" . $hse_name . ".$ext"; # Path to cfg file
            #    open (my $FILEid, '<', $FILEpath) or die ("can't open file: $FILEpath");
            #    $hse_file->{$ext} = [<$FILEid>];	# Slurp the entire file with one line per array element
            #    close $FILEid;
            #    # Create backups of old files
            #    rename $FILEpath, "$FILEpath.orig";
            #    unlink $FILEpath;
            #};
            #
            ## Update simulation parameters
            #&replace ($hse_file->{'cfg'}, "#SIM_PRESET_LINE2: start day; start month; end day; end month; simulation preset name", 1, -2, "%s\n", "*sps 1 4 12 1 4 0");
            
            # Update input.xml file
            my $XML = $dir . "/" . "input.xml";
            rename $XML, "$XML.orig";
            unlink $XML;
            copy("../Input_upgrade/timestep.xml",$XML) or die "Copy failed: $!";

            # -----------------------------------------------
			# Print out each new esp-r house file for the house record
			# -----------------------------------------------
			#FILE_PRINTOUT: {
			#	foreach my $ext (keys %{$hse_file}) {	# go through each extention inclusive of the zones for this particular record
            #        if ($ext =~ m/^(opr|con|htc|geo|tmc)$/) { # Template file, remove it from HASH
            #            undef $hse_file->{$ext};
            #        } else {
            #            my $file = $dir . "/$hse_name.";
            #            my $FILE;
            #            open ($FILE, '>', $file . $ext) or die ("Can't open datafile: $file$ext");	# open writeable file
            #            foreach my $line (@{$hse_file->{$ext}}) {print $FILE "$line";};	# loop through each element of the array (i.e. line of the final file) and print each line out
            #        };
			#	};
			#};
        };
        
    print "Thread for Timestep reports mode of $hse_type $region - Complete\n";
    
    return (1);
    
    };  # END sub main
};	# END MAIN

# -----------------------------------------------
# Subroutines
# -----------------------------------------------
SUBROUTINES: {

    sub clean_up_dir {
        my $set_name = shift;
        my $file = shift;

        # Find all the "orig" files for the model and reinstate them
        my @files = glob "$file/*.orig";
        for (0..$#files){
            my $To_Del = $files[$_];
            $To_Del =~ s/\.orig$//; # Name of new file to be removed
            unlink $To_Del;
            rename $files[$_],$To_Del;
        };

    	return (1);
	};

};
